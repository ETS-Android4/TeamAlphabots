Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RoboticArm.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.CRServo;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\n\r\nimport javax.tools.ForwardingFileObject;\r\n\r\n@Autonomous(name=\"RoboticArm\", group=\"Training\")\r\npublic class RoboticArm extends OpMode {\r\n\r\n\r\n\r\n    DcMotor leftWheel;\r\n    DcMotor rightWheel;\r\n    DcMotor backLeftWheel;\r\n    DcMotor backRightWheel;\r\n    DcMotor armMotor;\r\n    DcMotor carouselMotor;\r\n    double drivePower = 0.5;\r\n    int rotation = 1000; //1 rotation = 360\r\n\r\n\r\n\r\n\r\n\r\n\r\n    private ElapsedTime runtime= new ElapsedTime();\r\n\r\n    public void carouselFunc() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void init() {\r\n        leftWheel = hardwareMap.dcMotor.get(\"left_wheel\");\r\n        rightWheel = hardwareMap.dcMotor.get(\"right_wheel\");\r\n        armMotor = hardwareMap.get(DcMotor.class, \"expansion_motor\");\r\n        backRightWheel = hardwareMap.dcMotor.get(\"back_right_wheel\");\r\n        backLeftWheel = hardwareMap.dcMotor.get(\"back_left_wheel\");\r\n\r\n\r\n    }\r\n\r\n    public void Sleep(int milliseconds) {\r\n        try {\r\n            Thread.sleep(milliseconds);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public void resetEncoders() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n        shippingHubLevel(65);\r\n        resetEncoders();\r\n\r\n        shippingHubLevel(125);\r\n        resetEncoders();\r\n\r\n        shippingHubLevel(195);\r\n\r\n        shippingHubLevel(230);\r\n        resetEncoders();\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n    }\r\n\r\n\r\n    public void shippingHubLevel(int rotation) {\r\n        armMotor.setTargetPosition(rotation);\r\n        armMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        armMotor.setPower(1);\r\n        Sleep(1000);\r\n        armMotor.setTargetPosition(-rotation);\r\n        armMotor.setPower(0.04);\r\n    }\r\n    public void\r\n    public void diagonalLeft(int rotation) {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n        rightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(milliseconds 1000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backwardsDiagonalLeft(int rotation) {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        rightWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(2000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n    public void diagonalRight(int rotation) {\r\n        /*\r\n        backRightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        leftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n         */\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void horizontalRight(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void horizontalLeft(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n    }\r\n\r\n    public void backwardsDiagonalRight(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n    }\r\n\r\n\r\n\r\n    public void forward(int rotation) {\r\n\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backward(int rotation) {\r\n\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RoboticArm.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RoboticArm.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RoboticArm.java	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RoboticArm.java	(date 1637117891528)
@@ -100,7 +100,7 @@
         armMotor.setTargetPosition(-rotation);
         armMotor.setPower(0.04);
     }
-    public void
+
     public void diagonalLeft(int rotation) {
         /*
         backLeftWheel.setDirection(DcMotor.Direction.REVERSE);
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CarouselAutonomous.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.CRServo;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\nimport javax.tools.ForwardingFileObject;\r\n\r\n@Autonomous(name=\"CarouselAutonomous\", group=\"Training\")\r\npublic class CarouselAutonomous extends OpMode {\r\n\r\n\r\n\r\n    DcMotor leftWheel;\r\n    DcMotor rightWheel;\r\n    DcMotor backLeftWheel;\r\n    DcMotor backRightWheel;\r\n    DcMotor armMotor;\r\n    DcMotor carouselMotor;\r\n    double drivePower = 0.5;\r\n    int rotation = 1000; //1 rotation = 360\r\n\r\n\r\n\r\n\r\n\r\n\r\n    private ElapsedTime runtime= new ElapsedTime();\r\n\r\n    @Override\r\n    public void init() {\r\n        leftWheel = hardwareMap.dcMotor.get(\"left_wheel\");\r\n        rightWheel = hardwareMap.dcMotor.get(\"right_wheel\");\r\n        armMotor = hardwareMap.get(DcMotor.class, \"expansion_motor\");\r\n        backRightWheel = hardwareMap.dcMotor.get(\"back_right_wheel\");\r\n        backLeftWheel = hardwareMap.dcMotor.get(\"back_left_wheel\");\r\n\r\n\r\n    }\r\n\r\n    public void Sleep(int milliseconds) {\r\n        try {\r\n            Thread.sleep(milliseconds);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public void resetEncoders() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n        shippingHubLevel(65);\r\n        resetEncoders();\r\n\r\n        shippingHubLevel(125);\r\n        resetEncoders();\r\n\r\n        shippingHubLevel(195);\r\n        resetEncoders();\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n    }\r\n\r\n\r\n    public void shippingHubLevel(int rotation) {\r\n        armMotor.setTargetPosition(rotation);\r\n        armMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        armMotor.setPower(1);\r\n        Sleep(1000);\r\n        armMotor.setTargetPosition(-rotation);\r\n        armMotor.setPower(0.04);\r\n    }\r\n    public void carouselFuncAuto() {\r\n\r\n    }\r\n\r\n    public void carouselFunc(){\r\n        boolean carouselTurn;\r\n\r\n        carouselTurn = gamepad1.cross;\r\n        if(carouselTurn == true){\r\n            carouselMotor.setPower(0.5);\r\n        }\r\n        else{\r\n            carouselMotor.setPower(0);\r\n            carouselMotor.setPower(0.5)\r\n        }\r\n    }\r\n    public void diagonalLeft(int rotation) {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n        rightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(milliseconds 1000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backwardsDiagonalLeft(int rotation) {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        rightWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(2000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n    public void diagonalRight(int rotation) {\r\n        /*\r\n        backRightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        leftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n         */\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void horizontalRight(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void horizontalLeft(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n    }\r\n\r\n    public void backwardsDiagonalRight(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n    }\r\n\r\n\r\n\r\n    public void forward(int rotation) {\r\n\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backward(int rotation) {\r\n\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CarouselAutonomous.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CarouselAutonomous.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CarouselAutonomous.java	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/CarouselAutonomous.java	(date 1637117868134)
@@ -106,7 +106,7 @@
         }
         else{
             carouselMotor.setPower(0);
-            carouselMotor.setPower(0.5)
+            carouselMotor.setPower(0.5);
         }
     }
     public void diagonalLeft(int rotation) {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ColorSensorTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\nimport com.qualcomm.hardware.rev.RevColorSensorV3;\r\nimport com.qualcomm.robotcore.hardware.ColorSensor;\r\n\r\nimport android.app.Activity;\r\nimport android.graphics.Color;\r\nimport android.view.View;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.ColorSensor;\r\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\r\n\r\nimport java.util.Locale;\r\nimport edu.wpi.first.wpilibj.util.Color;\r\n@Autonomous(name=\"ColorSensorTest\", group=\"Training\")\r\n    public class ColorSensorTest extends OpMode {\r\n\r\n\r\n\r\n    DcMotor leftWheel;\r\n    DcMotor rightWheel;\r\n    DcMotor backLeftWheel;\r\n    DcMotor backRightWheel;\r\n    ColorSensor sensorColor;\r\n    double drivePower = 0.5;\r\n     //1 rotation = 360\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    private ElapsedTime runtime= new ElapsedTime();\r\n\r\n    @Override\r\n    public void init() {\r\n        leftWheel = hardwareMap.dcMotor.get(\"left_wheel\");\r\n        rightWheel = hardwareMap.dcMotor.get(\"right_wheel\");\r\n        backRightWheel = hardwareMap.dcMotor.get(\"back_right_wheel\");\r\n        backLeftWheel = hardwareMap.dcMotor.get(\"back_left_wheel\");\r\n        sensorColor = hardwareMap.get(ColorSensor.class, \"color_sensor\");\r\n\r\n\r\n    }\r\n\r\n    public void Sleep(int milliseconds) {\r\n        try {\r\n            Thread.sleep(milliseconds);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public void resetEncoders() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n\r\n\r\n\r\n        /*\r\n        Sleep(1000);\r\n        resetEncoders();\r\n\r\n        horizontalRight(1000);\r\n        Sleep(1000);\r\n        resetEncoders();\r\n\r\n\r\n        backward(1000);\r\n        Sleep(3000);\r\n        resetEncoders();\r\n\r\n        horizontalLeft(1000);\r\n        Sleep(1000);\r\n        resetEncoders();\r\n\r\n         */\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n\r\n        telemetry.addData(\"Red\", sensorColor.red());\r\n        telemetry.addData(\"Green\", sensorColor.green());\r\n        telemetry.addData(\"Blue\", sensorColor.blue());\r\n        telemetry.addData(\"Color\", getColor());\r\n\r\n\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    public void diagonalLeft(int rotation) {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n        rightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(milliseconds 1000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backwardsDiagonalLeft(int rotation) {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        rightWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(2000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n    public void diagonalRight(int rotation) {\r\n        /*\r\n        backRightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        leftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n         */\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void horizontalRight(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void horizontalLeft(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n    }\r\n\r\n    public void backwardsDiagonalRight(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n    }\r\n\r\n\r\n\r\n    public void forward(int rotation) {\r\n\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backward(int rotation) {\r\n\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ColorSensorTest.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ColorSensorTest.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ColorSensorTest.java	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ColorSensorTest.java	(date 1637117828348)
@@ -18,9 +18,8 @@
 import com.qualcomm.robotcore.hardware.DistanceSensor;
 
 import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;
-
+import java.lang.Object;
 import java.util.Locale;
-import edu.wpi.first.wpilibj.util.Color;
 @Autonomous(name="ColorSensorTest", group="Training")
     public class ColorSensorTest extends OpMode {
 
@@ -30,7 +29,7 @@
     DcMotor rightWheel;
     DcMotor backLeftWheel;
     DcMotor backRightWheel;
-    ColorSensor sensorColor;
+    RevColorSensorV3 sensorColor;
     double drivePower = 0.5;
      //1 rotation = 360
 
@@ -52,10 +51,14 @@
         rightWheel = hardwareMap.dcMotor.get("right_wheel");
         backRightWheel = hardwareMap.dcMotor.get("back_right_wheel");
         backLeftWheel = hardwareMap.dcMotor.get("back_left_wheel");
-        sensorColor = hardwareMap.get(ColorSensor.class, "color_sensor");
+        sensorColor = hardwareMap.get(RevColorSensorV3.class, "color_sensor");
+        sensorColor.enableLed(true);
+
 
 
     }
+
+
 
     public void Sleep(int milliseconds) {
         try {
@@ -100,11 +103,10 @@
 
     @Override
     public void loop() {
-
+        telemetry.addData("Light", sensorColor.getLightDetected());
         telemetry.addData("Red", sensorColor.red());
         telemetry.addData("Green", sensorColor.green());
         telemetry.addData("Blue", sensorColor.blue());
-        telemetry.addData("Color", getColor());
 
 
     }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.CRServo;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\n@TeleOp(name=\"TeleOpTest\", group=\"Training\")\r\n    public class TeleOpTest extends OpMode {\r\n\r\n\r\n\r\n    DcMotor leftWheel;\r\n    DcMotor rightWheel;\r\n    DcMotor backLeftWheel;\r\n    DcMotor backRightWheel;\r\n    DcMotor armMotor;\r\n    CRServo intakeServo;\r\n    DcMotor carouselMotor;\r\n    double drivePower = 0.5;\r\n    int rotation = 1000; //1 rotation = 360\r\n\r\n    private ElapsedTime runtime= new ElapsedTime();\r\n\r\n\r\n\r\n\r\n    public void spin() {\r\n        double pivot = 0;\r\n        pivot = gamepad1.right_stick_y;;\r\n        if(pivot < 0) {\r\n            rightWheel.setPower(-pivot);\r\n            backRightWheel.setPower(-pivot);\r\n            leftWheel.setPower(pivot);\r\n            backLeftWheel.setPower(pivot);\r\n        }\r\n        if(pivot > 0) {\r\n            rightWheel.setPower(-pivot);\r\n            backRightWheel.setPower(-pivot);\r\n            leftWheel.setPower(pivot);\r\n            backLeftWheel.setPower(pivot);\r\n        }\r\n    }\r\n\r\n\r\n    public void moveDriveTrain() {\r\n        double vertical = 0; //Moves forwards and backwards\r\n        double horizontal = 0; //Move side-to-side\r\n        double peevot = 0;\r\n\r\n        vertical = -gamepad1.left_stick_y;\r\n        horizontal = gamepad1.left_stick_x;\r\n        peevot = gamepad1.right_stick_x;\r\n        rightWheel.setPower(peevot + (-vertical + horizontal));\r\n        backRightWheel.setPower(peevot + (-vertical - horizontal));\r\n        leftWheel.setPower(peevot + (-vertical - horizontal));\r\n        backLeftWheel.setPower(peevot + (-vertical + horizontal));\r\n\r\n        spin();\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public void init() {\r\n        leftWheel = hardwareMap.dcMotor.get(\"left_wheel\");\r\n        rightWheel = hardwareMap.dcMotor.get(\"right_wheel\");\r\n        backRightWheel = hardwareMap.dcMotor.get(\"back_right_wheel\");\r\n        backLeftWheel = hardwareMap.dcMotor.get(\"back_left_wheel\");\r\n        intakeServo = hardwareMap.crservo.get(\"expansion_servo\");\r\n        carouselMotor = hardwareMap.get(DcMotor.class, \"carousel_arm\");\r\n\r\n        rightWheel.setDirection(DcMotorSimple.Direction.REVERSE); //rightWheel\r\n        backRightWheel.setDirection(DcMotorSimple.Direction.REVERSE); //backRightWheel\r\n\r\n    }\r\n\r\n    public void Sleep(int milliseconds) {\r\n        try {\r\n            Thread.sleep(milliseconds);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public void resetEncoders() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n        moveDriveTrain();\r\n        intakeFunc();\r\n        outakeFunc();\r\n        carouselFunc();\r\n\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    //@Override\r\n    //public void loop() {\r\n    //    leftWheel.setPower(drivePower);\r\n    //    rightWheel.setPower(drivePower);\r\n    //    backRightWheel.setPower(drivePower);\r\n    //    backLeftWheel.setPower(drivePower);\r\n\r\n\r\n//    }\r\n    public void carouselFunc(){\r\n        boolean carouselTurn;\r\n\r\n        carouselTurn = gamepad1.cross;\r\n        if(carouselTurn == true){\r\n            carouselMotor.setPower(0.5);\r\n        }\r\n        else{\r\n            carouselMotor.setPower(0);\r\n            carouselMotor.setPower(0.5)\r\n        }\r\n    }\r\n\r\n    public void intakeFunc() {\r\n        boolean inteeke;\r\n        inteeke = gamepad1.right_bumper;\r\n        if (inteeke == true) {\r\n            intakeServo.setPower(1);\r\n        }\r\n        else{\r\n            intakeServo.setPower(0);\r\n        }\r\n    }\r\n\r\n    public void outakeFunc(){\r\n        boolean outeeke;\r\n        outeeke = gamepad1.left_bumper;\r\n        if(outeeke == true) {\r\n            intakeServo.setPower(-1);\r\n        }\r\n        else{\r\n            intakeServo.setPower(0);\r\n        }\r\n    }\r\n    public void diagonalLeft() {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n        rightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(milliseconds 1000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backwardsDiagonalLeft() {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        rightWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(2000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n    public void diagonalRight() {\r\n        /*\r\n        backRightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        leftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n         */\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void right() {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void left() {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n    }\r\n\r\n    public void backwardsDiagonalRight() {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n\r\n\r\n    public void forward() {\r\n\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n        leftWheel.setTargetPosition(-300);\r\n        rightWheel.setTargetPosition(300);\r\n        backLeftWheel.setTargetPosition(-300);\r\n        backRightWheel.setTargetPosition(300);\r\n\r\n        leftWheel.setPower(-0.2);\r\n        rightWheel.setPower(0.2);\r\n        backLeftWheel.setPower(-0.2);\r\n        backRightWheel.setPower(0.2);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backward() {\r\n\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java	(date 1637118878347)
@@ -140,7 +140,6 @@
         }
         else{
             carouselMotor.setPower(0);
-            carouselMotor.setPower(0.5)
         }
     }
 
@@ -165,6 +164,8 @@
             intakeServo.setPower(0);
         }
     }
+
+
     public void diagonalLeft() {
         /*
         backLeftWheel.setDirection(DcMotor.Direction.REVERSE);
Index: .idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_10_PM_[Default_Changelist]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_10_PM_[Default_Changelist]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_10_PM_[Default_Changelist]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_10_PM_[Default_Changelist]/shelved.patch	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
+++ /dev/null	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
@@ -1,24 +0,0 @@
-Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.CRServo;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\n@TeleOp(name=\"TeleOpTest\", group=\"Training\")\r\n    public class TeleOpTest extends OpMode {\r\n\r\n\r\n\r\n    DcMotor leftWheel;\r\n    DcMotor rightWheel;\r\n    DcMotor backLeftWheel;\r\n    DcMotor backRightWheel;\r\n    DcMotor armMotor;\r\n    CRServo intake;\r\n    double drivePower = 0.5;\r\n    int rotation = 1000; //1 rotation = 360\r\n\r\n    private ElapsedTime runtime= new ElapsedTime();\r\n\r\n\r\n    public void servoSpin() {\r\n        float forwardsSpin  = gamepad1.right_trigger;\r\n        float backwardsSpin = gamepad1.left_trigger;\r\n        if(forwardsSpin > 0) {\r\n            intake.setPower(forwardsSpin);\r\n        }\r\n        if(backwardsSpin > 0) {\r\n            intake.setPower(-backwardsSpin);\r\n        }\r\n    }\r\n\r\n    public void spin() {\r\n        double pivot = 0;\r\n        pivot = gamepad1.right_stick_y;;\r\n        if(pivot < 0) {\r\n            rightWheel.setPower(-pivot);\r\n            backRightWheel.setPower(-pivot);\r\n            leftWheel.setPower(pivot);\r\n            backLeftWheel.setPower(pivot);\r\n        }\r\n        if(pivot > 0) {\r\n            rightWheel.setPower(-pivot);\r\n            backRightWheel.setPower(-pivot);\r\n            leftWheel.setPower(pivot);\r\n            backLeftWheel.setPower(pivot);\r\n        }\r\n    }\r\n\r\n\r\n    public void moveDriveTrain() {\r\n        double vertical = 0; //Moves forwards and backwards\r\n        double horizontal = 0; //Move side-to-side\r\n        double peevot = 0;\r\n\r\n        vertical = -gamepad1.left_stick_y;\r\n        horizontal = gamepad1.left_stick_x;\r\n        peevot = gamepad1.right_stick_x;\r\n        rightWheel.setPower(peevot + (-vertical + horizontal));\r\n        backRightWheel.setPower(peevot + (-vertical - horizontal));\r\n        leftWheel.setPower(peevot + (-vertical - horizontal));\r\n        backLeftWheel.setPower(peevot + (-vertical + horizontal));\r\n\r\n        spin();\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public void init() {\r\n        leftWheel = hardwareMap.dcMotor.get(\"left_wheel\");\r\n        rightWheel = hardwareMap.dcMotor.get(\"right_wheel\");\r\n        backRightWheel = hardwareMap.dcMotor.get(\"back_right_wheel\");\r\n        backLeftWheel = hardwareMap.dcMotor.get(\"back_left_wheel\");\r\n        intake = hardwareMap.crservo.get(\"expansion_servo\");\r\n\r\n        rightWheel.setDirection(DcMotorSimple.Direction.REVERSE); //rightWheel\r\n        backRightWheel.setDirection(DcMotorSimple.Direction.REVERSE); //backRightWheel\r\n\r\n    }\r\n\r\n    public void Sleep(int milliseconds) {\r\n        try {\r\n            Thread.sleep(milliseconds);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public void resetEncoders() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n        moveDriveTrain();\r\n        servoSpin();\r\n\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    //@Override\r\n    //public void loop() {\r\n    //    leftWheel.setPower(drivePower);\r\n    //    rightWheel.setPower(drivePower);\r\n    //    backRightWheel.setPower(drivePower);\r\n    //    backLeftWheel.setPower(drivePower);\r\n\r\n\r\n//    }\r\n\r\n    public void intakeFunc(){\r\n        boolean inteeke;\r\n        inteeke = gamepad1.right_bumper;\r\n        while(inteeke == true){\r\n            intake.setPower(1);\r\n        }\r\n    }\r\n    public void diagonalLeft() {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n        rightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(milliseconds 1000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backwardsDiagonalLeft() {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        rightWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(2000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n    public void diagonalRight() {\r\n        /*\r\n        backRightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        leftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n         */\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void right() {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void left() {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n    }\r\n\r\n    public void backwardsDiagonalRight() {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n\r\n\r\n    public void forward() {\r\n\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n        leftWheel.setTargetPosition(-300);\r\n        rightWheel.setTargetPosition(300);\r\n        backLeftWheel.setTargetPosition(-300);\r\n        backRightWheel.setTargetPosition(300);\r\n\r\n        leftWheel.setPower(-0.2);\r\n        rightWheel.setPower(0.2);\r\n        backLeftWheel.setPower(-0.2);\r\n        backRightWheel.setPower(0.2);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backward() {\r\n\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java
---- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java	(revision d8bfe3fb43aa2f260c14e9a76d324d1fd90f9f3e)
-+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java	(date 1636315813052)
-@@ -29,11 +29,8 @@
-     public void servoSpin() {
-         float forwardsSpin  = gamepad1.right_trigger;
-         float backwardsSpin = gamepad1.left_trigger;
--        if(forwardsSpin > 0) {
--            intake.setPower(forwardsSpin);
--        }
--        if(backwardsSpin > 0) {
--            intake.setPower(-backwardsSpin);
-+        while(forwardsSpin > 0) {
-+
-         }
-     }
- 
Index: .idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_10_PM__Default_Changelist_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_10_PM__Default_Changelist_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_10_PM__Default_Changelist_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_10_PM__Default_Changelist_.xml	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
+++ /dev/null	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_11_7_2021_12_10_PM_[Default_Changelist]" date="1636315816570" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_10_PM_[Default_Changelist]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 11/7/2021 12:10 PM [Default Changelist]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_03_PM__Default_Changelist_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_03_PM__Default_Changelist_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_03_PM__Default_Changelist_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_03_PM__Default_Changelist_.xml	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
+++ /dev/null	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_11_7_2021_12_03_PM_[Default_Changelist]" date="1636315406405" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_03_PM_[Default_Changelist]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 11/7/2021 12:03 PM [Default Changelist]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_03_PM_[Default_Changelist]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_03_PM_[Default_Changelist]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_03_PM_[Default_Changelist]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_11_7_2021_12_03_PM_[Default_Changelist]/shelved.patch	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
+++ /dev/null	(revision 0b1c17f53b48a97fa86bc7bd58326e9771c2c3c1)
@@ -1,46 +0,0 @@
-Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.CRServo;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\n@TeleOp(name=\"TeleOpTest\", group=\"Training\")\r\n    public class TeleOpTest extends OpMode {\r\n\r\n\r\n\r\n    DcMotor leftWheel;\r\n    DcMotor rightWheel;\r\n    DcMotor backLeftWheel;\r\n    DcMotor backRightWheel;\r\n    DcMotor armMotor;\r\n    CRServo intake;\r\n    double drivePower = 0.5;\r\n    int rotation = 1000; //1 rotation = 360\r\n\r\n    private ElapsedTime runtime= new ElapsedTime();\r\n\r\n\r\n    public void servoSpin() {\r\n        if(gamepad1.right_trigger > 1) {\r\n            intake.setPower(gamepad1.right_trigger);\r\n        }\r\n        if(gamepad1.left_trigger > 1) {\r\n            intake.setPower(gamepad1.left_trigger);\r\n        }\r\n    }\r\n\r\n    public void spin() {\r\n        double pivot = 0;\r\n        pivot = gamepad1.right_stick_y;;\r\n        if(pivot < 0) {\r\n            rightWheel.setPower(-pivot);\r\n            backRightWheel.setPower(-pivot);\r\n            leftWheel.setPower(pivot);\r\n            backLeftWheel.setPower(pivot);\r\n        }\r\n        if(pivot > 0) {\r\n            rightWheel.setPower(-pivot);\r\n            backRightWheel.setPower(-pivot);\r\n            leftWheel.setPower(pivot);\r\n            backLeftWheel.setPower(pivot);\r\n        }\r\n    }\r\n\r\n\r\n    public void moveDriveTrain() {\r\n        double vertical = 0; //Moves forwards and backwards\r\n        double horizontal = 0; //Move side-to-side\r\n        double peevot = 0;\r\n\r\n        vertical = -gamepad1.left_stick_y;\r\n        horizontal = gamepad1.left_stick_x;\r\n        peevot = gamepad1.right_stick_x;\r\n        rightWheel.setPower(peevot + (-vertical + horizontal));\r\n        backRightWheel.setPower(peevot + (-vertical - horizontal));\r\n        leftWheel.setPower(peevot + (-vertical - horizontal));\r\n        backLeftWheel.setPower(peevot + (-vertical + horizontal));\r\n\r\n        spin();\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public void init() {\r\n        leftWheel = hardwareMap.dcMotor.get(\"left_wheel\");\r\n        rightWheel = hardwareMap.dcMotor.get(\"right_wheel\");\r\n        backRightWheel = hardwareMap.dcMotor.get(\"back_right_wheel\");\r\n        backLeftWheel = hardwareMap.dcMotor.get(\"back_left_wheel\");\r\n        armMotor = hardwareMap.dcMotor.get(\"expansion_motor\");\r\n\r\n        rightWheel.setDirection(DcMotorSimple.Direction.REVERSE); //rightWheel\r\n        backRightWheel.setDirection(DcMotorSimple.Direction.REVERSE); //backRightWheel\r\n\r\n    }\r\n\r\n    public void Sleep(int milliseconds) {\r\n        try {\r\n            Thread.sleep(milliseconds);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public void resetEncoders() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n        moveDriveTrain();\r\n        armMotor.setPower(0.1);\r\n\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    //@Override\r\n    //public void loop() {\r\n    //    leftWheel.setPower(drivePower);\r\n    //    rightWheel.setPower(drivePower);\r\n    //    backRightWheel.setPower(drivePower);\r\n    //    backLeftWheel.setPower(drivePower);\r\n\r\n\r\n//    }\r\n\r\n\r\n    public void diagonalLeft() {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n        rightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(milliseconds 1000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backwardsDiagonalLeft() {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        rightWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(2000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n    public void diagonalRight() {\r\n        /*\r\n        backRightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        leftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n         */\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void right() {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void left() {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n    }\r\n\r\n    public void backwardsDiagonalRight() {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n\r\n\r\n    public void forward() {\r\n\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n        leftWheel.setTargetPosition(-300);\r\n        rightWheel.setTargetPosition(300);\r\n        backLeftWheel.setTargetPosition(-300);\r\n        backRightWheel.setTargetPosition(300);\r\n\r\n        leftWheel.setPower(-0.2);\r\n        rightWheel.setPower(0.2);\r\n        backLeftWheel.setPower(-0.2);\r\n        backRightWheel.setPower(0.2);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backward() {\r\n\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java
---- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java	(revision 8cfa70d7eccf2d2a1dd8475e5e79f0925b25b66c)
-+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java	(date 1636315402606)
-@@ -27,11 +27,13 @@
- 
- 
-     public void servoSpin() {
--        if(gamepad1.right_trigger > 1) {
--            intake.setPower(gamepad1.right_trigger);
-+        float forwardsSpin  = gamepad1.right_trigger;
-+        float backwardsSpin = gamepad1.left_trigger;
-+        if(forwardsSpin > 0) {
-+            intake.setPower(forwardsSpin);
-         }
--        if(gamepad1.left_trigger > 1) {
--            intake.setPower(gamepad1.left_trigger);
-+        if(backwardsSpin > 0) {
-+            intake.setPower(-backwardsSpin);
-         }
-     }
- 
-@@ -77,7 +79,7 @@
-         rightWheel = hardwareMap.dcMotor.get("right_wheel");
-         backRightWheel = hardwareMap.dcMotor.get("back_right_wheel");
-         backLeftWheel = hardwareMap.dcMotor.get("back_left_wheel");
--        armMotor = hardwareMap.dcMotor.get("expansion_motor");
-+        intake = hardwareMap.crservo.get("expansion_servo");
- 
-         rightWheel.setDirection(DcMotorSimple.Direction.REVERSE); //rightWheel
-         backRightWheel.setDirection(DcMotorSimple.Direction.REVERSE); //backRightWheel
-@@ -108,7 +110,7 @@
-     @Override
-     public void loop() {
-         moveDriveTrain();
--        armMotor.setPower(0.1);
-+        servoSpin();
- 
-     }
-     @Override
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Vuforia.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Vuforia.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Vuforia.java
new file mode 100644
--- /dev/null	(date 1637119831964)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Vuforia.java	(date 1637119831964)
@@ -0,0 +1,335 @@
+/* Copyright (c) 2017 FIRST. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted (subject to the limitations in the disclaimer below) provided that
+ * the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this list
+ * of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * Neither the name of FIRST nor the names of its contributors may be used to endorse or
+ * promote products derived from this software without specific prior written permission.
+ *
+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
+ * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.firstinspires.ftc.teamcode;
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
+import com.qualcomm.robotcore.eventloop.opmode.Disabled;
+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
+import com.qualcomm.robotcore.util.RobotLog;
+
+import org.firstinspires.ftc.robotcore.external.ClassFactory;
+import org.firstinspires.ftc.robotcore.external.matrices.MatrixF;
+import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
+import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
+import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
+import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
+import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This 2016-2017 OpMode illustrates the basics of using the Vuforia localizer to determine
+ * positioning and orientation of robot on the FTC field.
+ * The code is structured as a LinearOpMode
+ *
+ * Vuforia uses the phone's camera to inspect it's surroundings, and attempt to locate target images.
+ *
+ * When images are located, Vuforia is able to determine the position and orientation of the
+ * image relative to the camera.  This sample code than combines that information with a
+ * knowledge of where the target images are on the field, to determine the location of the camera.
+ *
+ * This example assumes a "diamond" field configuration where the red and blue alliance stations
+ * are adjacent on the corner of the field furthest from the audience.
+ * From the Audience perspective, the Red driver station is on the right.
+ * The two vision target are located on the two walls closest to the audience, facing in.
+ * The Stones are on the RED side of the field, and the Chips are on the Blue side.
+ *
+ * A final calculation then uses the location of the camera on the robot to determine the
+ * robot's location and orientation on the field.
+ *
+ * @see VuforiaLocalizer
+ * @see VuforiaTrackableDefaultListener
+ * see  ftc_app/doc/tutorial/FTC_FieldCoordinateSystemDefinition.pdf
+ *
+ * Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.
+ * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list.
+ *
+ * IMPORTANT: In order to use this OpMode, you need to obtain your own Vuforia license key as
+ * is explained below.
+ */
+
+@Autonomous(name="Vuforia", group ="Concept")
+public class Vuforia extends LinearOpMode {
+
+    public static final String TAG = "Vuforia Navigation Sample";
+
+    OpenGLMatrix lastLocation = null;
+
+    /**
+     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia
+     * localization engine.
+     */
+    VuforiaLocalizer vuforia;
+
+    @Override public void runOpMode() {
+        /*
+         * To start up Vuforia, tell it the view that we wish to use for camera monitor (on the RC phone);
+         * If no camera monitor is desired, use the parameterless constructor instead (commented out below).
+         */
+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);
+
+        // OR...  Do Not Activate the Camera Monitor View, to save power
+        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();
+
+        /*
+         * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which
+         * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.
+         * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer
+         * web site at https://developer.vuforia.com/license-manager.
+         *
+         * Vuforia license keys are always 380 characters long, and look as if they contain mostly
+         * random data. As an example, here is a example of a fragment of a valid key:
+         *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...
+         * Once you've obtained a license key, copy the string from the Vuforia web site
+         * and paste it in to your code on the next line, between the double quotes.
+         */
+        parameters.vuforiaLicenseKey = " -- YOUR NEW VUFORIA KEY GOES HERE  --- ";
+
+        /*
+         * We also indicate which camera on the RC that we wish to use.
+         * Here we chose the back (HiRes) camera (for greater range), but
+         * for a competition robot, the front camera might be more convenient.
+         */
+        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.BACK;
+
+        /**
+         * Instantiate the Vuforia engine
+         */
+        vuforia = ClassFactory.getInstance().createVuforia(parameters);
+
+        /**
+         * Load the data sets that for the trackable objects we wish to track. These particular data
+         * sets are stored in the 'assets' part of our application (you'll see them in the Android
+         * Studio 'Project' view over there on the left of the screen). You can make your own datasets
+         * with the Vuforia Target Manager: https://developer.vuforia.com/target-manager. PDFs for the
+         * example "StonesAndChips", datasets can be found in in this project in the
+         * documentation directory.
+         */
+        VuforiaTrackables stonesAndChips = this.vuforia.loadTrackablesFromAsset("StonesAndChips");
+        VuforiaTrackable redTarget = stonesAndChips.get(0);
+        redTarget.setName("RedTarget");  // Stones
+
+        VuforiaTrackable blueTarget  = stonesAndChips.get(1);
+        blueTarget.setName("BlueTarget");  // Chips
+
+        /** For convenience, gather together all the trackable objects in one easily-iterable collection */
+        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();
+        allTrackables.addAll(stonesAndChips);
+
+        /**
+         * We use units of mm here because that's the recommended units of measurement for the
+         * size values specified in the XML for the ImageTarget trackables in data sets. E.g.:
+         *      <ImageTarget name="stones" size="247 173"/>
+         * You don't *have to* use mm here, but the units here and the units used in the XML
+         * target configuration files *must* correspond for the math to work out correctly.
+         */
+        float mmPerInch        = 25.4f;
+        float mmBotWidth       = 18 * mmPerInch;            // ... or whatever is right for your robot
+        float mmFTCFieldWidth  = (12*12 - 2) * mmPerInch;   // the FTC field is ~11'10" center-to-center of the glass panels
+
+        /**
+         * In order for localization to work, we need to tell the system where each target we
+         * wish to use for navigation resides on the field, and we need to specify where on the robot
+         * the phone resides. These specifications are in the form of <em>transformation matrices.</em>
+         * Transformation matrices are a central, important concept in the math here involved in localization.
+         * See <a href="https://en.wikipedia.org/wiki/Transformation_matrix">Transformation Matrix</a>
+         * for detailed information. Commonly, you'll encounter transformation matrices as instances
+         * of the {@link OpenGLMatrix} class.
+         *
+         * For the most part, you don't need to understand the details of the math of how transformation
+         * matrices work inside (as fascinating as that is, truly). Just remember these key points:
+         * <ol>
+         *
+         *     <li>You can put two transformations together to produce a third that combines the effect of
+         *     both of them. If, for example, you have a rotation transform R and a translation transform T,
+         *     then the combined transformation matrix RT which does the rotation first and then the translation
+         *     is given by {@code RT = T.multiplied(R)}. That is, the transforms are multiplied in the
+         *     <em>reverse</em> of the chronological order in which they applied.</li>
+         *
+         *     <li>A common way to create useful transforms is to use methods in the {@link OpenGLMatrix}
+         *     class and the Orientation class. See, for example, {@link OpenGLMatrix#translation(float,
+         *     float, float)}, {@link OpenGLMatrix#rotation(AngleUnit, float, float, float, float)}, and
+         *     {@link Orientation#getRotationMatrix(AxesReference, AxesOrder, AngleUnit, float, float, float)}.
+         *     Related methods in {@link OpenGLMatrix}, such as {@link OpenGLMatrix#rotated(AngleUnit,
+         *     float, float, float, float)}, are syntactic shorthands for creating a new transform and
+         *     then immediately multiplying the receiver by it, which can be convenient at times.</li>
+         *
+         *     <li>If you want to break open the black box of a transformation matrix to understand
+         *     what it's doing inside, use {@link MatrixF#getTranslation()} to fetch how much the
+         *     transform will move you in x, y, and z, and use {@link Orientation#getOrientation(MatrixF,
+         *     AxesReference, AxesOrder, AngleUnit)} to determine the rotational motion that the transform
+         *     will impart. See {@link #format(OpenGLMatrix)} below for an example.</li>
+         *
+         * </ol>
+         *
+         * This example places the "stones" image on the perimeter wall to the Left
+         *  of the Red Driver station wall.  Similar to the Red Beacon Location on the Res-Q
+         *
+         * This example places the "chips" image on the perimeter wall to the Right
+         *  of the Blue Driver station.  Similar to the Blue Beacon Location on the Res-Q
+         *
+         * See the doc folder of this project for a description of the field Axis conventions.
+         *
+         * Initially the target is conceptually lying at the origin of the field's coordinate system
+         * (the center of the field), facing up.
+         *
+         * In this configuration, the target's coordinate system aligns with that of the field.
+         *
+         * In a real situation we'd also account for the vertical (Z) offset of the target,
+         * but for simplicity, we ignore that here; for a real robot, you'll want to fix that.
+         *
+         * To place the Stones Target on the Red Audience wall:
+         * - First we rotate it 90 around the field's X axis to flip it upright
+         * - Then we rotate it  90 around the field's Z access to face it away from the audience.
+         * - Finally, we translate it back along the X axis towards the red audience wall.
+         */
+        OpenGLMatrix redTargetLocationOnField = OpenGLMatrix
+                /* Then we translate the target off to the RED WALL. Our translation here
+                is a negative translation in X.*/
+                .translation(-mmFTCFieldWidth/2, 0, 0)
+                .multiplied(Orientation.getRotationMatrix(
+                        /* First, in the fixed (field) coordinate system, we rotate 90deg in X, then 90 in Z */
+                        AxesReference.EXTRINSIC, AxesOrder.XZX,
+                        AngleUnit.DEGREES, 90, 90, 0));
+        redTarget.setLocation(redTargetLocationOnField);
+        RobotLog.ii(TAG, "Red Target=%s", format(redTargetLocationOnField));
+
+        /*
+         * To place the Stones Target on the Blue Audience wall:
+         * - First we rotate it 90 around the field's X axis to flip it upright
+         * - Finally, we translate it along the Y axis towards the blue audience wall.
+         */
+        OpenGLMatrix blueTargetLocationOnField = OpenGLMatrix
+                /* Then we translate the target off to the Blue Audience wall.
+                Our translation here is a positive translation in Y.*/
+                .translation(0, mmFTCFieldWidth/2, 0)
+                .multiplied(Orientation.getRotationMatrix(
+                        /* First, in the fixed (field) coordinate system, we rotate 90deg in X */
+                        AxesReference.EXTRINSIC, AxesOrder.XZX,
+                        AngleUnit.DEGREES, 90, 0, 0));
+        blueTarget.setLocation(blueTargetLocationOnField);
+        RobotLog.ii(TAG, "Blue Target=%s", format(blueTargetLocationOnField));
+
+        /**
+         * Create a transformation matrix describing where the phone is on the robot. Here, we
+         * put the phone on the right hand side of the robot with the screen facing in (see our
+         * choice of BACK camera above) and in landscape mode. Starting from alignment between the
+         * robot's and phone's axes, this is a rotation of -90deg along the Y axis.
+         *
+         * When determining whether a rotation is positive or negative, consider yourself as looking
+         * down the (positive) axis of rotation from the positive towards the origin. Positive rotations
+         * are then CCW, and negative rotations CW. An example: consider looking down the positive Z
+         * axis towards the origin. A positive rotation about Z (ie: a rotation parallel to the the X-Y
+         * plane) is then CCW, as one would normally expect from the usual classic 2D geometry.
+         */
+        OpenGLMatrix phoneLocationOnRobot = OpenGLMatrix
+                .translation(mmBotWidth/2,0,0)
+                .multiplied(Orientation.getRotationMatrix(
+                        AxesReference.EXTRINSIC, AxesOrder.YZY,
+                        AngleUnit.DEGREES, -90, 0, 0));
+        RobotLog.ii(TAG, "phone=%s", format(phoneLocationOnRobot));
+
+        /**
+         * Let the trackable listeners we care about know where the phone is. We know that each
+         * listener is a {@link VuforiaTrackableDefaultListener} and can so safely cast because
+         * we have not ourselves installed a listener of a different type.
+         */
+        ((VuforiaTrackableDefaultListener)redTarget.getListener()).setPhoneInformation(phoneLocationOnRobot, parameters.cameraDirection);
+        ((VuforiaTrackableDefaultListener)blueTarget.getListener()).setPhoneInformation(phoneLocationOnRobot, parameters.cameraDirection);
+
+        /**
+         * A brief tutorial: here's how all the math is going to work:
+         *
+         * C = phoneLocationOnRobot  maps   phone coords -> robot coords
+         * P = tracker.getPose()     maps   image target coords -> phone coords
+         * L = redTargetLocationOnField maps   image target coords -> field coords
+         *
+         * So
+         *
+         * C.inverted()              maps   robot coords -> phone coords
+         * P.inverted()              maps   phone coords -> imageTarget coords
+         *
+         * Putting that all together,
+         *
+         * L x P.inverted() x C.inverted() maps robot coords to field coords.
+         *
+         * @see VuforiaTrackableDefaultListener#getRobotLocation()
+         */
+
+        /** Wait for the game to begin */
+        telemetry.addData(">", "Press Play to start tracking");
+        telemetry.update();
+        waitForStart();
+
+        /** Start tracking the data sets we care about. */
+        stonesAndChips.activate();
+
+        while (opModeIsActive()) {
+
+            for (VuforiaTrackable trackable : allTrackables) {
+                /**
+                 * getUpdatedRobotLocation() will return null if no new information is available since
+                 * the last time that call was made, or if the trackable is not currently visible.
+                 * getRobotLocation() will return null if the trackable is not currently visible.
+                 */
+                telemetry.addData(trackable.getName(), ((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible() ? "Visible" : "Not Visible");    //
+
+                OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)trackable.getListener()).getUpdatedRobotLocation();
+                if (robotLocationTransform != null) {
+                    lastLocation = robotLocationTransform;
+                }
+            }
+            /**
+             * Provide feedback as to where the robot was last located (if we know).
+             */
+            if (lastLocation != null) {
+                //  RobotLog.vv(TAG, "robot=%s", format(lastLocation));
+                telemetry.addData("Pos", format(lastLocation));
+            } else {
+                telemetry.addData("Pos", "Unknown");
+            }
+            telemetry.update();
+        }
+    }
+
+    /**
+     * A simple utility that extracts positioning information from a transformation matrix
+     * and formats it in a form palatable to a human being.
+     */
+    String format(OpenGLMatrix transformationMatrix) {
+        return transformationMatrix.formatAsTransform();
+    }
+}
