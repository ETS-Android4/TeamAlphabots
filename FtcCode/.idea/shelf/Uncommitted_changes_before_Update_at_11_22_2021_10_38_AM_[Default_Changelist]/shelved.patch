Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ColorSensorTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\nimport com.qualcomm.hardware.rev.RevColorSensorV3;\r\nimport com.qualcomm.robotcore.hardware.ColorSensor;\r\n\r\nimport android.app.Activity;\r\nimport android.graphics.Color;\r\nimport android.view.View;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.ColorSensor;\r\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\r\nimport java.lang.Object;\r\nimport java.util.Locale;\r\n@Autonomous(name=\"ColorSensorTest\", group=\"Training\")\r\n    public class ColorSensorTest extends OpMode {\r\n\r\n\r\n\r\n    DcMotor leftWheel;\r\n    DcMotor rightWheel;\r\n    DcMotor backLeftWheel;\r\n    DcMotor backRightWheel;\r\n    RevColorSensorV3 sensorColor;\r\n    double drivePower = 0.5;\r\n     //1 rotation = 360\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    private ElapsedTime runtime= new ElapsedTime();\r\n\r\n    @Override\r\n    public void init() {\r\n        leftWheel = hardwareMap.dcMotor.get(\"left_wheel\");\r\n        rightWheel = hardwareMap.dcMotor.get(\"right_wheel\");\r\n        backRightWheel = hardwareMap.dcMotor.get(\"back_right_wheel\");\r\n        backLeftWheel = hardwareMap.dcMotor.get(\"back_left_wheel\");\r\n        sensorColor = hardwareMap.get(RevColorSensorV3.class, \"color_sensor\");\r\n        sensorColor.enableLed(true);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    public void Sleep(int milliseconds) {\r\n        try {\r\n            Thread.sleep(milliseconds);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public void resetEncoders() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n\r\n\r\n\r\n        /*\r\n        Sleep(1000);\r\n        resetEncoders();\r\n\r\n        horizontalRight(1000);\r\n        Sleep(1000);\r\n        resetEncoders();\r\n\r\n\r\n        backward(1000);\r\n        Sleep(3000);\r\n        resetEncoders();\r\n\r\n        horizontalLeft(1000);\r\n        Sleep(1000);\r\n        resetEncoders();\r\n\r\n         */\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n        telemetry.addData(\"Light\", sensorColor.getLightDetected());\r\n        telemetry.addData(\"Distance\", sensorColor.getDistance(DistanceUnit.CM));\r\n        telemetry.addData(\"Red\", sensorColor.red());\r\n        telemetry.addData(\"Raw Optical\", sensorColor.rawOptical());\r\n        telemetry.addData(\"Raw Light Detected Max\", sensorColor.getRawLightDetectedMax());\r\n        telemetry.addData(\"Status\", sensorColor.status());\r\n        telemetry.addData(\"Green\", sensorColor.green());\r\n        telemetry.addData(\"Blue\", sensorColor.blue());\r\n\r\n\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    public void diagonalLeft(int rotation) {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n        rightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(milliseconds 1000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backwardsDiagonalLeft(int rotation) {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        rightWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(2000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n    public void diagonalRight(int rotation) {\r\n        /*\r\n        backRightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        leftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n         */\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void horizontalRight(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void horizontalLeft(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n    }\r\n\r\n    public void backwardsDiagonalRight(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n    }\r\n\r\n\r\n\r\n    public void forward(int rotation) {\r\n\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backward(int rotation) {\r\n\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ColorSensorTest.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ColorSensorTest.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ColorSensorTest.java	(revision 8031acb3fdb1a24cac0a17a07f9d3ebc3c035071)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ColorSensorTest.java	(date 1637519405243)
@@ -103,12 +103,10 @@
 
     @Override
     public void loop() {
-        telemetry.addData("Light", sensorColor.getLightDetected());
+
+        telemetry.addData("Normalized Color", sensorColor.getNormalizedColors());
         telemetry.addData("Distance", sensorColor.getDistance(DistanceUnit.CM));
         telemetry.addData("Red", sensorColor.red());
-        telemetry.addData("Raw Optical", sensorColor.rawOptical());
-        telemetry.addData("Raw Light Detected Max", sensorColor.getRawLightDetectedMax());
-        telemetry.addData("Status", sensorColor.status());
         telemetry.addData("Green", sensorColor.green());
         telemetry.addData("Blue", sensorColor.blue());
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestDrive1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\n@Autonomous(name=\"TestDrive1\", group=\"Training\")\r\n    public class TestDrive1 extends OpMode {\r\n\r\n\r\n\r\n    DcMotor leftWheel;\r\n    DcMotor rightWheel;\r\n    DcMotor backLeftWheel;\r\n    DcMotor backRightWheel;\r\n    double drivePower = 0.5;\r\n     //1 rotation = 360\r\n\r\n\r\n\r\n\r\n\r\n    private ElapsedTime runtime= new ElapsedTime();\r\n\r\n    @Override\r\n    public void init() {\r\n        leftWheel = hardwareMap.dcMotor.get(\"left_wheel\");\r\n        rightWheel = hardwareMap.dcMotor.get(\"right_wheel\");\r\n        backRightWheel = hardwareMap.dcMotor.get(\"back_right_wheel\");\r\n        backLeftWheel = hardwareMap.dcMotor.get(\"back_left_wheel\");\r\n\r\n    }\r\n\r\n    public void Sleep(int milliseconds) {\r\n        try {\r\n            Thread.sleep(milliseconds);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public void resetEncoders() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    public void diagonalLeft(int rotation) {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n        rightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(milliseconds 1000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backwardsDiagonalLeft(int rotation) {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        rightWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(2000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n    public void diagonalRight(int rotation) {\r\n        /*\r\n        backRightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        leftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n         */\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void horizontalRight(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void horizontalLeft(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n    }\r\n\r\n    public void backwardsDiagonalRight(int rotation) {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n    }\r\n\r\n\r\n\r\n    public void forward(int rotation) {\r\n\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backward(int rotation) {\r\n\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestDrive1.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestDrive1.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestDrive1.java	(revision 8031acb3fdb1a24cac0a17a07f9d3ebc3c035071)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TestDrive1.java	(date 1637532373157)
@@ -56,7 +56,7 @@
 
     @Override
     public void loop() {
-
+        leftWheel.setPower(drivePower);
     }
     @Override
     public void stop() {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.CRServo;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\n@TeleOp(name=\"TeleOpTest\", group=\"Training\")\r\n    public class TeleOpTest extends OpMode {\r\n\r\n\r\n\r\n    DcMotor leftWheel;\r\n    DcMotor rightWheel;\r\n    DcMotor backLeftWheel;\r\n    DcMotor backRightWheel;\r\n    DcMotor armMotor;\r\n    CRServo intakeServo;\r\n    DcMotor carouselMotor;\r\n    double drivePower = 0.5;\r\n    int rotation = 1000; //1 rotation = 360\r\n\r\n    private ElapsedTime runtime= new ElapsedTime();\r\n\r\n\r\n\r\n\r\n    public void spin() {\r\n        double pivot = 0;\r\n        pivot = gamepad1.right_stick_y;;\r\n        if(pivot < 0) {\r\n            rightWheel.setPower(-pivot);\r\n            backRightWheel.setPower(-pivot);\r\n            leftWheel.setPower(pivot);\r\n            backLeftWheel.setPower(pivot);\r\n        }\r\n        if(pivot > 0) {\r\n            rightWheel.setPower(-pivot);\r\n            backRightWheel.setPower(-pivot);\r\n            leftWheel.setPower(pivot);\r\n            backLeftWheel.setPower(pivot);\r\n        }\r\n    }\r\n\r\n\r\n    public void moveDriveTrain() {\r\n        double vertical = 0; //Moves forwards and backwards\r\n        double horizontal = 0; //Move side-to-side\r\n        double peevot = 0;\r\n\r\n        vertical = -gamepad1.left_stick_y;\r\n        horizontal = gamepad1.left_stick_x;\r\n        peevot = gamepad1.right_stick_x;\r\n        rightWheel.setPower(peevot + (-vertical + horizontal));\r\n        backRightWheel.setPower(peevot + (-vertical - horizontal));\r\n        leftWheel.setPower(peevot + (-vertical - horizontal));\r\n        backLeftWheel.setPower(peevot + (-vertical + horizontal));\r\n\r\n        spin();\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public void init() {\r\n        leftWheel = hardwareMap.dcMotor.get(\"left_wheel\");\r\n        rightWheel = hardwareMap.dcMotor.get(\"right_wheel\");\r\n        backRightWheel = hardwareMap.dcMotor.get(\"back_right_wheel\");\r\n        backLeftWheel = hardwareMap.dcMotor.get(\"back_left_wheel\");\r\n        intakeServo = hardwareMap.crservo.get(\"expansion_servo\");\r\n        armMotor = hardwareMap.dcMotor.get(\"expansion_motor\");\r\n        carouselMotor = hardwareMap.get(DcMotor.class, \"carousel_arm\");\r\n\r\n        rightWheel.setDirection(DcMotorSimple.Direction.REVERSE); //rightWheel\r\n        backRightWheel.setDirection(DcMotorSimple.Direction.REVERSE); //backRightWheel\r\n\r\n    }\r\n\r\n    public void Sleep(int milliseconds) {\r\n        try {\r\n            Thread.sleep(milliseconds);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public void resetEncoders() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n        moveDriveTrain();\r\n        intakeFunc();\r\n        outakeFunc();\r\n        setButtons();\r\n\r\n    }\r\n    @Override\r\n    public void stop() {\r\n        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    //@Override\r\n    //public void loop() {\r\n    //    leftWheel.setPower(drivePower);\r\n    //    rightWheel.setPower(drivePower);\r\n    //    backRightWheel.setPower(drivePower);\r\n    //    backLeftWheel.setPower(drivePower);\r\n\r\n\r\n//    }\r\n    public void setButtons(){\r\n        if(gamepad1.dpad_left == true){\r\n            shippingHubLevel(65);\r\n        }\r\n        if(gamepad1.dpad_right == true){\r\n            shippingHubLevel(125 );\r\n        }\r\n        if(gamepad1.dpad_up == true){\r\n            shippingHubLevel(195);\r\n        }\r\n        if(gamepad1.triangle == true){\r\n            shippingHubLevelReturn(195);\r\n        }\r\n        if(gamepad1.circle == true){\r\n            shippingHubLevelReturn(125);\r\n        }\r\n        if(gamepad1.square == true){\r\n            shippingHubLevelReturn(65);\r\n        }\r\n        if(gamepad1.cross == true){\r\n            carouselFunc(7);\r\n        }\r\n    }\r\n    public void shippingHubLevel(int rotation) {\r\n        armMotor.setTargetPosition(rotation);\r\n        armMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        armMotor.setPower(1);\r\n    }\r\n    public void shippingHubLevelReturn(int rotation){\r\n        armMotor.setTargetPosition(-rotation);\r\n        armMotor.setPower(0.04);\r\n    }\r\n    public void carouselFunc(int rotation){\r\n            carouselMotor.setTargetPosition(-rotation);\r\n        carouselMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n            carouselMotor.setPower(0.5);\r\n    }\r\n\r\n    public void intakeFunc() {\r\n        boolean inteeke;\r\n        inteeke = gamepad1.left_bumper;\r\n        if (inteeke == true) {\r\n            intakeServo.setPower(1);\r\n        }\r\n        else{\r\n            intakeServo.setPower(0);\r\n        }\r\n    }\r\n\r\n    public void outakeFunc(){\r\n        boolean outeeke;\r\n        outeeke = gamepad1.right_bumper;\r\n        if(outeeke == true) {\r\n            intakeServo.setPower(-1);\r\n        }\r\n        else{\r\n            intakeServo.setPower(0);\r\n        }\r\n    }\r\n    public void accelerate(){\r\n        if(gamepad2.right_bumper == true){\r\n            drivePower = drivePower + 0.25;\r\n        }\r\n        else{\r\n            drivePower = 0.5;\r\n        }\r\n    }\r\n    public void deccelerate(){\r\n        if(gamepad2.left_bumper == true){\r\n            drivePower = drivePower - 0.25;\r\n        }\r\n        else{\r\n            drivePower = 0.5;\r\n        }\r\n    }\r\n    public void stopMotors(){\r\n        if(gamepad2.square == true){\r\n            drivePower = 0;\r\n        }\r\n        else{\r\n            drivePower = 0.5;\r\n        }\r\n    }\r\n\r\n\r\n    public void diagonalLeft() {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n        rightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(milliseconds 1000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backwardsDiagonalLeft() {\r\n        /*\r\n        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        rightWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        //sleep(2000);\r\n\r\n         */\r\n\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n    public void diagonalRight() {\r\n        /*\r\n        backRightWheel.setDirection(DcMotor.Direction.FORWARD);\r\n        leftWheel.setDirection(DcMotor.Direction.REVERSE);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n         */\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void right() {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n    }\r\n\r\n    public void left() {\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n    }\r\n\r\n    public void backwardsDiagonalRight() {\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n    }\r\n\r\n\r\n\r\n    public void forward() {\r\n\r\n\r\n        leftWheel.setTargetPosition(-rotation);\r\n        rightWheel.setTargetPosition(rotation);\r\n        backLeftWheel.setTargetPosition(-rotation);\r\n        backRightWheel.setTargetPosition(rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(-drivePower);\r\n        rightWheel.setPower(drivePower);\r\n        backLeftWheel.setPower(-drivePower);\r\n        backRightWheel.setPower(drivePower);\r\n\r\n        leftWheel.setTargetPosition(-300);\r\n        rightWheel.setTargetPosition(300);\r\n        backLeftWheel.setTargetPosition(-300);\r\n        backRightWheel.setTargetPosition(300);\r\n\r\n        leftWheel.setPower(-0.2);\r\n        rightWheel.setPower(0.2);\r\n        backLeftWheel.setPower(-0.2);\r\n        backRightWheel.setPower(0.2);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void backward() {\r\n\r\n\r\n        leftWheel.setTargetPosition(rotation);\r\n        rightWheel.setTargetPosition(-rotation);\r\n        backLeftWheel.setTargetPosition(rotation);\r\n        backRightWheel.setTargetPosition(-rotation);\r\n\r\n        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n\r\n        leftWheel.setPower(drivePower);\r\n        rightWheel.setPower(-drivePower);\r\n        backLeftWheel.setPower(drivePower);\r\n        backRightWheel.setPower(-drivePower);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java	(revision 8031acb3fdb1a24cac0a17a07f9d3ebc3c035071)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOpTest.java	(date 1637530297520)
@@ -107,6 +107,7 @@
         intakeFunc();
         outakeFunc();
         setButtons();
+        carouselFunc(0.3);
 
     }
     @Override
@@ -151,9 +152,7 @@
         if(gamepad1.square == true){
             shippingHubLevelReturn(65);
         }
-        if(gamepad1.cross == true){
-            carouselFunc(7);
-        }
+
     }
     public void shippingHubLevel(int rotation) {
         armMotor.setTargetPosition(rotation);
@@ -164,15 +163,18 @@
         armMotor.setTargetPosition(-rotation);
         armMotor.setPower(0.04);
     }
-    public void carouselFunc(int rotation){
-            carouselMotor.setTargetPosition(-rotation);
-        carouselMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
-            carouselMotor.setPower(0.5);
+    public void carouselFunc(double power){
+        if(gamepad1.cross == true) {
+            carouselMotor.setPower(power);
+
+        } else {
+            carouselMotor.setPower(0);
+        }
     }
 
     public void intakeFunc() {
-        boolean inteeke;
-        inteeke = gamepad1.left_bumper;
+
+        boolean inteeke = gamepad1.left_bumper;
         if (inteeke == true) {
             intakeServo.setPower(1);
         }
@@ -191,6 +193,7 @@
             intakeServo.setPower(0);
         }
     }
+    /*
     public void accelerate(){
         if(gamepad2.right_bumper == true){
             drivePower = drivePower + 0.25;
@@ -207,6 +210,8 @@
             drivePower = 0.5;
         }
     }
+
+
     public void stopMotors(){
         if(gamepad2.square == true){
             drivePower = 0;
@@ -216,6 +221,8 @@
         }
     }
 
+     */
+
 
     public void diagonalLeft() {
         /*
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Vuforia.java
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Vuforia.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Vuforia.java
deleted file mode 100644
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Vuforia.java	(revision 8031acb3fdb1a24cac0a17a07f9d3ebc3c035071)
+++ /dev/null	(revision 8031acb3fdb1a24cac0a17a07f9d3ebc3c035071)
@@ -1,335 +0,0 @@
-/* Copyright (c) 2017 FIRST. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted (subject to the limitations in the disclaimer below) provided that
- * the following conditions are met:
- *
- * Redistributions of source code must retain the above copyright notice, this list
- * of conditions and the following disclaimer.
- *
- * Redistributions in binary form must reproduce the above copyright notice, this
- * list of conditions and the following disclaimer in the documentation and/or
- * other materials provided with the distribution.
- *
- * Neither the name of FIRST nor the names of its contributors may be used to endorse or
- * promote products derived from this software without specific prior written permission.
- *
- * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
- * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package org.firstinspires.ftc.teamcode;
-import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
-import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
-import com.qualcomm.robotcore.eventloop.opmode.Disabled;
-import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
-import com.qualcomm.robotcore.util.RobotLog;
-
-import org.firstinspires.ftc.robotcore.external.ClassFactory;
-import org.firstinspires.ftc.robotcore.external.matrices.MatrixF;
-import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;
-import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
-import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
-import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
-import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
-import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
-import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;
-import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;
-import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * This 2016-2017 OpMode illustrates the basics of using the Vuforia localizer to determine
- * positioning and orientation of robot on the FTC field.
- * The code is structured as a LinearOpMode
- *
- * Vuforia uses the phone's camera to inspect it's surroundings, and attempt to locate target images.
- *
- * When images are located, Vuforia is able to determine the position and orientation of the
- * image relative to the camera.  This sample code than combines that information with a
- * knowledge of where the target images are on the field, to determine the location of the camera.
- *
- * This example assumes a "diamond" field configuration where the red and blue alliance stations
- * are adjacent on the corner of the field furthest from the audience.
- * From the Audience perspective, the Red driver station is on the right.
- * The two vision target are located on the two walls closest to the audience, facing in.
- * The Stones are on the RED side of the field, and the Chips are on the Blue side.
- *
- * A final calculation then uses the location of the camera on the robot to determine the
- * robot's location and orientation on the field.
- *
- * @see VuforiaLocalizer
- * @see VuforiaTrackableDefaultListener
- * see  ftc_app/doc/tutorial/FTC_FieldCoordinateSystemDefinition.pdf
- *
- * Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.
- * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list.
- *
- * IMPORTANT: In order to use this OpMode, you need to obtain your own Vuforia license key as
- * is explained below.
- */
-
-@Autonomous(name="Vuforia", group ="Concept")
-public class Vuforia extends LinearOpMode {
-
-    public static final String TAG = "Vuforia Navigation Sample";
-
-    OpenGLMatrix lastLocation = null;
-
-    /**
-     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia
-     * localization engine.
-     */
-    VuforiaLocalizer vuforia;
-
-    @Override public void runOpMode() {
-        /*
-         * To start up Vuforia, tell it the view that we wish to use for camera monitor (on the RC phone);
-         * If no camera monitor is desired, use the parameterless constructor instead (commented out below).
-         */
-        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
-        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);
-
-        // OR...  Do Not Activate the Camera Monitor View, to save power
-        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();
-
-        /*
-         * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which
-         * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.
-         * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer
-         * web site at https://developer.vuforia.com/license-manager.
-         *
-         * Vuforia license keys are always 380 characters long, and look as if they contain mostly
-         * random data. As an example, here is a example of a fragment of a valid key:
-         *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...
-         * Once you've obtained a license key, copy the string from the Vuforia web site
-         * and paste it in to your code on the next line, between the double quotes.
-         */
-        parameters.vuforiaLicenseKey = "VuforiaAutonomous";
-
-        /*
-         * We also indicate which camera on the RC that we wish to use.
-         * Here we chose the back (HiRes) camera (for greater range), but
-         * for a competition robot, the front camera might be more convenient.
-         */
-        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.BACK;
-
-        /**
-         * Instantiate the Vuforia engine
-         */
-        vuforia = ClassFactory.getInstance().createVuforia(parameters);
-
-        /**
-         * Load the data sets that for the trackable objects we wish to track. These particular data
-         * sets are stored in the 'assets' part of our application (you'll see them in the Android
-         * Studio 'Project' view over there on the left of the screen). You can make your own datasets
-         * with the Vuforia Target Manager: https://developer.vuforia.com/target-manager. PDFs for the
-         * example "StonesAndChips", datasets can be found in in this project in the
-         * documentation directory.
-         */
-        VuforiaTrackables stonesAndChips = this.vuforia.loadTrackablesFromAsset("StonesAndChips");
-        VuforiaTrackable redTarget = stonesAndChips.get(0);
-        redTarget.setName("RedTarget");  // Stones
-
-        VuforiaTrackable blueTarget  = stonesAndChips.get(1);
-        blueTarget.setName("BlueTarget");  // Chips
-
-        /** For convenience, gather together all the trackable objects in one easily-iterable collection */
-        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();
-        allTrackables.addAll(stonesAndChips);
-
-        /**
-         * We use units of mm here because that's the recommended units of measurement for the
-         * size values specified in the XML for the ImageTarget trackables in data sets. E.g.:
-         *      <ImageTarget name="stones" size="247 173"/>
-         * You don't *have to* use mm here, but the units here and the units used in the XML
-         * target configuration files *must* correspond for the math to work out correctly.
-         */
-        float mmPerInch        = 25.4f;
-        float mmBotWidth       = 18 * mmPerInch;            // ... or whatever is right for your robot
-        float mmFTCFieldWidth  = (12*12 - 2) * mmPerInch;   // the FTC field is ~11'10" center-to-center of the glass panels
-
-        /**
-         * In order for localization to work, we need to tell the system where each target we
-         * wish to use for navigation resides on the field, and we need to specify where on the robot
-         * the phone resides. These specifications are in the form of <em>transformation matrices.</em>
-         * Transformation matrices are a central, important concept in the math here involved in localization.
-         * See <a href="https://en.wikipedia.org/wiki/Transformation_matrix">Transformation Matrix</a>
-         * for detailed information. Commonly, you'll encounter transformation matrices as instances
-         * of the {@link OpenGLMatrix} class.
-         *
-         * For the most part, you don't need to understand the details of the math of how transformation
-         * matrices work inside (as fascinating as that is, truly). Just remember these key points:
-         * <ol>
-         *
-         *     <li>You can put two transformations together to produce a third that combines the effect of
-         *     both of them. If, for example, you have a rotation transform R and a translation transform T,
-         *     then the combined transformation matrix RT which does the rotation first and then the translation
-         *     is given by {@code RT = T.multiplied(R)}. That is, the transforms are multiplied in the
-         *     <em>reverse</em> of the chronological order in which they applied.</li>
-         *
-         *     <li>A common way to create useful transforms is to use methods in the {@link OpenGLMatrix}
-         *     class and the Orientation class. See, for example, {@link OpenGLMatrix#translation(float,
-         *     float, float)}, {@link OpenGLMatrix#rotation(AngleUnit, float, float, float, float)}, and
-         *     {@link Orientation#getRotationMatrix(AxesReference, AxesOrder, AngleUnit, float, float, float)}.
-         *     Related methods in {@link OpenGLMatrix}, such as {@link OpenGLMatrix#rotated(AngleUnit,
-         *     float, float, float, float)}, are syntactic shorthands for creating a new transform and
-         *     then immediately multiplying the receiver by it, which can be convenient at times.</li>
-         *
-         *     <li>If you want to break open the black box of a transformation matrix to understand
-         *     what it's doing inside, use {@link MatrixF#getTranslation()} to fetch how much the
-         *     transform will move you in x, y, and z, and use {@link Orientation#getOrientation(MatrixF,
-         *     AxesReference, AxesOrder, AngleUnit)} to determine the rotational motion that the transform
-         *     will impart. See {@link #format(OpenGLMatrix)} below for an example.</li>
-         *
-         * </ol>
-         *
-         * This example places the "stones" image on the perimeter wall to the Left
-         *  of the Red Driver station wall.  Similar to the Red Beacon Location on the Res-Q
-         *
-         * This example places the "chips" image on the perimeter wall to the Right
-         *  of the Blue Driver station.  Similar to the Blue Beacon Location on the Res-Q
-         *
-         * See the doc folder of this project for a description of the field Axis conventions.
-         *
-         * Initially the target is conceptually lying at the origin of the field's coordinate system
-         * (the center of the field), facing up.
-         *
-         * In this configuration, the target's coordinate system aligns with that of the field.
-         *
-         * In a real situation we'd also account for the vertical (Z) offset of the target,
-         * but for simplicity, we ignore that here; for a real robot, you'll want to fix that.
-         *
-         * To place the Stones Target on the Red Audience wall:
-         * - First we rotate it 90 around the field's X axis to flip it upright
-         * - Then we rotate it  90 around the field's Z access to face it away from the audience.
-         * - Finally, we translate it back along the X axis towards the red audience wall.
-         */
-        OpenGLMatrix redTargetLocationOnField = OpenGLMatrix
-                /* Then we translate the target off to the RED WALL. Our translation here
-                is a negative translation in X.*/
-                .translation(-mmFTCFieldWidth/2, 0, 0)
-                .multiplied(Orientation.getRotationMatrix(
-                        /* First, in the fixed (field) coordinate system, we rotate 90deg in X, then 90 in Z */
-                        AxesReference.EXTRINSIC, AxesOrder.XZX,
-                        AngleUnit.DEGREES, 90, 90, 0));
-        redTarget.setLocation(redTargetLocationOnField);
-        RobotLog.ii(TAG, "Red Target=%s", format(redTargetLocationOnField));
-
-        /*
-         * To place the Stones Target on the Blue Audience wall:
-         * - First we rotate it 90 around the field's X axis to flip it upright
-         * - Finally, we translate it along the Y axis towards the blue audience wall.
-         */
-        OpenGLMatrix blueTargetLocationOnField = OpenGLMatrix
-                /* Then we translate the target off to the Blue Audience wall.
-                Our translation here is a positive translation in Y.*/
-                .translation(0, mmFTCFieldWidth/2, 0)
-                .multiplied(Orientation.getRotationMatrix(
-                        /* First, in the fixed (field) coordinate system, we rotate 90deg in X */
-                        AxesReference.EXTRINSIC, AxesOrder.XZX,
-                        AngleUnit.DEGREES, 90, 0, 0));
-        blueTarget.setLocation(blueTargetLocationOnField);
-        RobotLog.ii(TAG, "Blue Target=%s", format(blueTargetLocationOnField));
-
-        /**
-         * Create a transformation matrix describing where the phone is on the robot. Here, we
-         * put the phone on the right hand side of the robot with the screen facing in (see our
-         * choice of BACK camera above) and in landscape mode. Starting from alignment between the
-         * robot's and phone's axes, this is a rotation of -90deg along the Y axis.
-         *
-         * When determining whether a rotation is positive or negative, consider yourself as looking
-         * down the (positive) axis of rotation from the positive towards the origin. Positive rotations
-         * are then CCW, and negative rotations CW. An example: consider looking down the positive Z
-         * axis towards the origin. A positive rotation about Z (ie: a rotation parallel to the the X-Y
-         * plane) is then CCW, as one would normally expect from the usual classic 2D geometry.
-         */
-        OpenGLMatrix phoneLocationOnRobot = OpenGLMatrix
-                .translation(mmBotWidth/2,0,0)
-                .multiplied(Orientation.getRotationMatrix(
-                        AxesReference.EXTRINSIC, AxesOrder.YZY,
-                        AngleUnit.DEGREES, -90, 0, 0));
-        RobotLog.ii(TAG, "phone=%s", format(phoneLocationOnRobot));
-
-        /**
-         * Let the trackable listeners we care about know where the phone is. We know that each
-         * listener is a {@link VuforiaTrackableDefaultListener} and can so safely cast because
-         * we have not ourselves installed a listener of a different type.
-         */
-        ((VuforiaTrackableDefaultListener)redTarget.getListener()).setPhoneInformation(phoneLocationOnRobot, parameters.cameraDirection);
-        ((VuforiaTrackableDefaultListener)blueTarget.getListener()).setPhoneInformation(phoneLocationOnRobot, parameters.cameraDirection);
-
-        /**
-         * A brief tutorial: here's how all the math is going to work:
-         *
-         * C = phoneLocationOnRobot  maps   phone coords -> robot coords
-         * P = tracker.getPose()     maps   image target coords -> phone coords
-         * L = redTargetLocationOnField maps   image target coords -> field coords
-         *
-         * So
-         *
-         * C.inverted()              maps   robot coords -> phone coords
-         * P.inverted()              maps   phone coords -> imageTarget coords
-         *
-         * Putting that all together,
-         *
-         * L x P.inverted() x C.inverted() maps robot coords to field coords.
-         *
-         * @see VuforiaTrackableDefaultListener#getRobotLocation()
-         */
-
-        /** Wait for the game to begin */
-        telemetry.addData(">", "Press Play to start tracking");
-        telemetry.update();
-        waitForStart();
-
-        /** Start tracking the data sets we care about. */
-        stonesAndChips.activate();
-
-        while (opModeIsActive()) {
-
-            for (VuforiaTrackable trackable : allTrackables) {
-                /**
-                 * getUpdatedRobotLocation() will return null if no new information is available since
-                 * the last time that call was made, or if the trackable is not currently visible.
-                 * getRobotLocation() will return null if the trackable is not currently visible.
-                 */
-                telemetry.addData(trackable.getName(), ((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible() ? "Visible" : "Not Visible");    //
-
-                OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)trackable.getListener()).getUpdatedRobotLocation();
-                if (robotLocationTransform != null) {
-                    lastLocation = robotLocationTransform;
-                }
-            }
-            /**
-             * Provide feedback as to where the robot was last located (if we know).
-             */
-            if (lastLocation != null) {
-                //  RobotLog.vv(TAG, "robot=%s", format(lastLocation));
-                telemetry.addData("Pos", format(lastLocation));
-            } else {
-                telemetry.addData("Pos", "Unknown");
-            }
-            telemetry.update();
-        }
-    }
-
-    /**
-     * A simple utility that extracts positioning information from a transformation matrix
-     * and formats it in a form palatable to a human being.
-     */
-    String format(OpenGLMatrix transformationMatrix) {
-        return transformationMatrix.formatAsTransform();
-    }
-}
Index: .idea/deploymentTargetDropDown.xml
===================================================================
diff --git a/.idea/deploymentTargetDropDown.xml b/.idea/deploymentTargetDropDown.xml
deleted file mode 100644
--- a/.idea/deploymentTargetDropDown.xml	(revision 8031acb3fdb1a24cac0a17a07f9d3ebc3c035071)
+++ /dev/null	(revision 8031acb3fdb1a24cac0a17a07f9d3ebc3c035071)
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="deploymentTargetDropDown">
-    <runningDeviceTargetSelectedWithDropDown>
-      <Target>
-        <type value="RUNNING_DEVICE_TARGET" />
-        <deviceKey>
-          <Key>
-            <type value="SERIAL_NUMBER" />
-            <value value="eb301be5a11b8a79" />
-          </Key>
-        </deviceKey>
-      </Target>
-    </runningDeviceTargetSelectedWithDropDown>
-    <timeTargetWasSelectedWithDropDown value="2021-11-21T02:01:29.304703500Z" />
-  </component>
-</project>
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FrontLeftWheel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FrontLeftWheel.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FrontLeftWheel.java
new file mode 100644
--- /dev/null	(date 1637606285206)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FrontLeftWheel.java	(date 1637606285206)
@@ -0,0 +1,240 @@
+package org.firstinspires.ftc.teamcode;
+
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+import com.qualcomm.robotcore.eventloop.opmode.OpMode;
+import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.util.ElapsedTime;
+
+@Autonomous(name="FrontLeftWheel", group="Training")
+    public class FrontLeftWheel extends OpMode {
+
+
+
+    DcMotor leftWheel;
+    DcMotor rightWheel;
+    DcMotor backLeftWheel;
+    DcMotor backRightWheel;
+    double drivePower = 0.5;
+     //1 rotation = 360
+
+
+
+
+
+    private ElapsedTime runtime= new ElapsedTime();
+
+    @Override
+    public void init() {
+        leftWheel = hardwareMap.dcMotor.get("left_wheel");
+        rightWheel = hardwareMap.dcMotor.get("right_wheel");
+        backRightWheel = hardwareMap.dcMotor.get("back_right_wheel");
+        backLeftWheel = hardwareMap.dcMotor.get("back_left_wheel");
+
+    }
+
+    public void Sleep(int milliseconds) {
+        try {
+            Thread.sleep(milliseconds);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+    public void resetEncoders() {
+        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+    }
+
+    @Override
+    public void start() {
+
+
+
+    }
+
+    @Override
+    public void loop() {
+        leftWheel.setPower(drivePower);
+    }
+    @Override
+    public void stop() {
+        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+
+
+    }
+
+
+
+
+    public void diagonalLeft(int rotation) {
+        /*
+        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);
+        rightWheel.setDirection(DcMotor.Direction.FORWARD);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(drivePower);
+        //sleep(milliseconds 1000);
+
+         */
+
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+
+
+
+    }
+
+    public void backwardsDiagonalLeft(int rotation) {
+        /*
+        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);
+        rightWheel.setDirection(DcMotor.Direction.REVERSE);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(drivePower);
+        //sleep(2000);
+
+         */
+
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+
+    }
+
+    public void diagonalRight(int rotation) {
+        /*
+        backRightWheel.setDirection(DcMotor.Direction.FORWARD);
+        leftWheel.setDirection(DcMotor.Direction.REVERSE);
+
+        leftWheel.setPower(drivePower);
+        backRightWheel.setPower(drivePower);
+
+         */
+
+        leftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        backRightWheel.setPower(drivePower);
+    }
+
+    public void horizontalRight(int rotation) {
+
+        leftWheel.setTargetPosition(-rotation);
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+        backRightWheel.setPower(drivePower);
+    }
+
+    public void horizontalLeft(int rotation) {
+
+        leftWheel.setTargetPosition(rotation);
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+        backRightWheel.setPower(-drivePower);
+    }
+
+    public void backwardsDiagonalRight(int rotation) {
+
+        leftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        backRightWheel.setPower(-drivePower);
+
+    }
+
+
+
+    public void forward(int rotation) {
+
+
+        leftWheel.setTargetPosition(-rotation);
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+        backRightWheel.setPower(drivePower);
+
+
+
+
+    }
+
+    public void backward(int rotation) {
+
+
+        leftWheel.setTargetPosition(rotation);
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+        backRightWheel.setPower(-drivePower);
+
+
+
+    }
+
+
+
+
+
+
+}
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RearRightWheel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RearRightWheel.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RearRightWheel.java
new file mode 100644
--- /dev/null	(date 1637606285187)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RearRightWheel.java	(date 1637606285187)
@@ -0,0 +1,241 @@
+package org.firstinspires.ftc.teamcode;
+
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+import com.qualcomm.robotcore.eventloop.opmode.OpMode;
+import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.util.ElapsedTime;
+
+@Autonomous(name="RearRightWheel", group="Training")
+    public class RearRightWheel extends OpMode {
+
+
+
+    DcMotor leftWheel;
+    DcMotor rightWheel;
+    DcMotor backLeftWheel;
+    DcMotor backRightWheel;
+    double drivePower = 0.5;
+     //1 rotation = 360
+
+
+
+
+
+    private ElapsedTime runtime= new ElapsedTime();
+
+    @Override
+    public void init() {
+        leftWheel = hardwareMap.dcMotor.get("left_wheel");
+        rightWheel = hardwareMap.dcMotor.get("right_wheel");
+        backRightWheel = hardwareMap.dcMotor.get("back_right_wheel");
+        backLeftWheel = hardwareMap.dcMotor.get("back_left_wheel");
+
+    }
+
+    public void Sleep(int milliseconds) {
+        try {
+            Thread.sleep(milliseconds);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+    public void resetEncoders() {
+        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+    }
+
+    @Override
+    public void start() {
+
+
+
+
+    }
+
+    @Override
+    public void loop() {
+        backRightWheel.setPower(drivePower);
+    }
+    @Override
+    public void stop() {
+        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+
+
+    }
+
+
+
+
+    public void diagonalLeft(int rotation) {
+        /*
+        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);
+        rightWheel.setDirection(DcMotor.Direction.FORWARD);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(drivePower);
+        //sleep(milliseconds 1000);
+
+         */
+
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+
+
+
+    }
+
+    public void backwardsDiagonalLeft(int rotation) {
+        /*
+        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);
+        rightWheel.setDirection(DcMotor.Direction.REVERSE);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(drivePower);
+        //sleep(2000);
+
+         */
+
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+
+    }
+
+    public void diagonalRight(int rotation) {
+        /*
+        backRightWheel.setDirection(DcMotor.Direction.FORWARD);
+        leftWheel.setDirection(DcMotor.Direction.REVERSE);
+
+        leftWheel.setPower(drivePower);
+        backRightWheel.setPower(drivePower);
+
+         */
+
+        leftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        backRightWheel.setPower(drivePower);
+    }
+
+    public void horizontalRight(int rotation) {
+
+        leftWheel.setTargetPosition(-rotation);
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+        backRightWheel.setPower(drivePower);
+    }
+
+    public void horizontalLeft(int rotation) {
+
+        leftWheel.setTargetPosition(rotation);
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+        backRightWheel.setPower(-drivePower);
+    }
+
+    public void backwardsDiagonalRight(int rotation) {
+
+        leftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        backRightWheel.setPower(-drivePower);
+
+    }
+
+
+
+    public void forward(int rotation) {
+
+
+        leftWheel.setTargetPosition(-rotation);
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+        backRightWheel.setPower(drivePower);
+
+
+
+
+    }
+
+    public void backward(int rotation) {
+
+
+        leftWheel.setTargetPosition(rotation);
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+        backRightWheel.setPower(-drivePower);
+
+
+
+    }
+
+
+
+
+
+
+}
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RearLeftWheel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RearLeftWheel.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RearLeftWheel.java
new file mode 100644
--- /dev/null	(date 1637606219793)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RearLeftWheel.java	(date 1637606219793)
@@ -0,0 +1,240 @@
+package org.firstinspires.ftc.teamcode;
+
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+import com.qualcomm.robotcore.eventloop.opmode.OpMode;
+import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.util.ElapsedTime;
+
+@Autonomous(name="RearLeftWheel", group="Training")
+    public class RearLeftWheel extends OpMode {
+
+
+
+    DcMotor leftWheel;
+    DcMotor rightWheel;
+    DcMotor backLeftWheel;
+    DcMotor backRightWheel;
+    double drivePower = 0.5;
+     //1 rotation = 360
+
+
+
+
+
+    private ElapsedTime runtime= new ElapsedTime();
+
+    @Override
+    public void init() {
+        leftWheel = hardwareMap.dcMotor.get("left_wheel");
+        rightWheel = hardwareMap.dcMotor.get("right_wheel");
+        backRightWheel = hardwareMap.dcMotor.get("back_right_wheel");
+        backLeftWheel = hardwareMap.dcMotor.get("back_left_wheel");
+
+    }
+
+    public void Sleep(int milliseconds) {
+        try {
+            Thread.sleep(milliseconds);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+    public void resetEncoders() {
+        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+    }
+
+    @Override
+    public void start() {
+
+
+
+    }
+
+    @Override
+    public void loop() {
+        backLeftWheel.setPower(drivePower);
+    }
+    @Override
+    public void stop() {
+        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+
+
+    }
+
+
+
+
+    public void diagonalLeft(int rotation) {
+        /*
+        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);
+        rightWheel.setDirection(DcMotor.Direction.FORWARD);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(drivePower);
+        //sleep(milliseconds 1000);
+
+         */
+
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+
+
+
+    }
+
+    public void backwardsDiagonalLeft(int rotation) {
+        /*
+        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);
+        rightWheel.setDirection(DcMotor.Direction.REVERSE);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(drivePower);
+        //sleep(2000);
+
+         */
+
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+
+    }
+
+    public void diagonalRight(int rotation) {
+        /*
+        backRightWheel.setDirection(DcMotor.Direction.FORWARD);
+        leftWheel.setDirection(DcMotor.Direction.REVERSE);
+
+        leftWheel.setPower(drivePower);
+        backRightWheel.setPower(drivePower);
+
+         */
+
+        leftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        backRightWheel.setPower(drivePower);
+    }
+
+    public void horizontalRight(int rotation) {
+
+        leftWheel.setTargetPosition(-rotation);
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+        backRightWheel.setPower(drivePower);
+    }
+
+    public void horizontalLeft(int rotation) {
+
+        leftWheel.setTargetPosition(rotation);
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+        backRightWheel.setPower(-drivePower);
+    }
+
+    public void backwardsDiagonalRight(int rotation) {
+
+        leftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        backRightWheel.setPower(-drivePower);
+
+    }
+
+
+
+    public void forward(int rotation) {
+
+
+        leftWheel.setTargetPosition(-rotation);
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+        backRightWheel.setPower(drivePower);
+
+
+
+
+    }
+
+    public void backward(int rotation) {
+
+
+        leftWheel.setTargetPosition(rotation);
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+        backRightWheel.setPower(-drivePower);
+
+
+
+    }
+
+
+
+
+
+
+}
\ No newline at end of file
Index: FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2019 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage org.firstinspires.ftc.robotcontroller.external.samples;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport java.util.List;\r\nimport org.firstinspires.ftc.robotcore.external.ClassFactory;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;\r\nimport org.firstinspires.ftc.robotcore.external.tfod.Recognition;\r\n\r\n/**\r\n * This 2020-2021 OpMode illustrates the basics of using the TensorFlow Object Detection API to\r\n * determine the position of the Ultimate Goal game elements.\r\n *\r\n * Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\r\n * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list.\r\n *\r\n * IMPORTANT: In order to use this OpMode, you need to obtain your own Vuforia license key as\r\n * is explained below.\r\n */\r\n@TeleOp(name = \"Concept: TensorFlow Object Detection\", group = \"Concept\")\r\n@Disabled\r\npublic class ConceptTensorFlowObjectDetection extends LinearOpMode {\r\n    private static final String TFOD_MODEL_ASSET = \"UltimateGoal.tflite\";\r\n    private static final String LABEL_FIRST_ELEMENT = \"Quad\";\r\n    private static final String LABEL_SECOND_ELEMENT = \"Single\";\r\n\r\n    /*\r\n     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which\r\n     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.\r\n     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer\r\n     * web site at https://developer.vuforia.com/license-manager.\r\n     *\r\n     * Vuforia license keys are always 380 characters long, and look as if they contain mostly\r\n     * random data. As an example, here is a example of a fragment of a valid key:\r\n     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...\r\n     * Once you've obtained a license key, copy the string from the Vuforia web site\r\n     * and paste it in to your code on the next line, between the double quotes.\r\n     */\r\n    private static final String VUFORIA_KEY =\r\n            \" -- YOUR NEW VUFORIA KEY GOES HERE  --- \";\r\n\r\n    /**\r\n     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia\r\n     * localization engine.\r\n     */\r\n    private VuforiaLocalizer vuforia;\r\n\r\n    /**\r\n     * {@link #tfod} is the variable we will use to store our instance of the TensorFlow Object\r\n     * Detection engine.\r\n     */\r\n    private TFObjectDetector tfod;\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that\r\n        // first.\r\n        initVuforia();\r\n        initTfod();\r\n\r\n        /**\r\n         * Activate TensorFlow Object Detection before we wait for the start command.\r\n         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\r\n         **/\r\n        if (tfod != null) {\r\n            tfod.activate();\r\n\r\n            // The TensorFlow software will scale the input images from the camera to a lower resolution.\r\n            // This can result in lower detection accuracy at longer distances (> 55cm or 22\").\r\n            // If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\r\n            // to artificially zoom in to the center of image.  For best results, the \"aspectRatio\" argument\r\n            // should be set to the value of the images used to create the TensorFlow Object Detection model\r\n            // (typically 16/9).\r\n            tfod.setZoom(2.5, 16.0/9.0);\r\n        }\r\n\r\n        /** Wait for the game to begin */\r\n        telemetry.addData(\">\", \"Press Play to start op mode\");\r\n        telemetry.update();\r\n        waitForStart();\r\n\r\n        if (opModeIsActive()) {\r\n            while (opModeIsActive()) {\r\n                if (tfod != null) {\r\n                    // getUpdatedRecognitions() will return null if no new information is available since\r\n                    // the last time that call was made.\r\n                    List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\r\n                    if (updatedRecognitions != null) {\r\n                      telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\r\n\r\n                      // step through the list of recognitions and display boundary info.\r\n                      int i = 0;\r\n                      for (Recognition recognition : updatedRecognitions) {\r\n                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\r\n                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\r\n                                          recognition.getLeft(), recognition.getTop());\r\n                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\r\n                                recognition.getRight(), recognition.getBottom());\r\n                      }\r\n                      telemetry.update();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (tfod != null) {\r\n            tfod.shutdown();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize the Vuforia localization engine.\r\n     */\r\n    private void initVuforia() {\r\n        /*\r\n         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.\r\n         */\r\n        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();\r\n\r\n        parameters.vuforiaLicenseKey = VUFORIA_KEY;\r\n        parameters.cameraDirection = CameraDirection.BACK;\r\n\r\n        //  Instantiate the Vuforia engine\r\n        vuforia = ClassFactory.getInstance().createVuforia(parameters);\r\n\r\n        // Loading trackables is not necessary for the TensorFlow Object Detection engine.\r\n    }\r\n\r\n    /**\r\n     * Initialize the TensorFlow Object Detection engine.\r\n     */\r\n    private void initTfod() {\r\n        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\r\n            \"tfodMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);\r\n        tfodParameters.minResultConfidence = 0.8f;\r\n        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);\r\n        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetection.java b/FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetection.java
--- a/FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetection.java	(revision 8031acb3fdb1a24cac0a17a07f9d3ebc3c035071)
+++ b/FtcRobotController/src/main/java/org/firstinspires/ftc/robotcontroller/external/samples/ConceptTensorFlowObjectDetection.java	(date 1637521269061)
@@ -29,6 +29,7 @@
 
 package org.firstinspires.ftc.robotcontroller.external.samples;
 
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
 import com.qualcomm.robotcore.eventloop.opmode.Disabled;
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
@@ -49,10 +50,9 @@
  * IMPORTANT: In order to use this OpMode, you need to obtain your own Vuforia license key as
  * is explained below.
  */
-@TeleOp(name = "Concept: TensorFlow Object Detection", group = "Concept")
-@Disabled
+@Autonomous(name = "ConceptTensorFlowObjectDetectionTest", group = "Training")
 public class ConceptTensorFlowObjectDetection extends LinearOpMode {
-    private static final String TFOD_MODEL_ASSET = "UltimateGoal.tflite";
+    private static final String TFOD_MODEL_ASSET = "FreightFrenzy_BCDM.tflite";
     private static final String LABEL_FIRST_ELEMENT = "Quad";
     private static final String LABEL_SECOND_ELEMENT = "Single";
 
@@ -69,7 +69,7 @@
      * and paste it in to your code on the next line, between the double quotes.
      */
     private static final String VUFORIA_KEY =
-            " -- YOUR NEW VUFORIA KEY GOES HERE  --- ";
+            "AceJqxr/////AAABmfhCK5bvWUGbtwq2Aklej7UU4PMgSzBzmvS8GTqRPrVjYpKWEX6XGiwzt85GlEialLkazXNjPIK9y/u4QVNGg9ZytchGG9StZFyP2Wo9GCBa32Zr9jLSDq4kNCpaxFgfV/VhkmqvdzQjPG+i3LlRB8gnK/VCrS8ofYJe907hpUg9z2vS9SnTWzrdLGA3eAOs6oAY4FUBgzze/FFV44ufBZWsNBxBC2RqwEX1m60Q07xUt20q9pf7nU+XPLkbZxp0FCsUWETjdk08M9Oh+fgJJ56cyVey7I98zPRH39b5aOze3ynMkjcW2BjkI5e2VQN6GWe17Q662qUBwJ5R/yaFV0avDp1+u5aQqN8xdl+dfVIp";
 
     /**
      * {@link #vuforia} is the variable we will use to store our instance of the Vuforia
@@ -118,18 +118,18 @@
                     // the last time that call was made.
                     List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();
                     if (updatedRecognitions != null) {
-                      telemetry.addData("# Object Detected", updatedRecognitions.size());
+                        telemetry.addData("# Object Detected", updatedRecognitions.size());
 
-                      // step through the list of recognitions and display boundary info.
-                      int i = 0;
-                      for (Recognition recognition : updatedRecognitions) {
-                        telemetry.addData(String.format("label (%d)", i), recognition.getLabel());
-                        telemetry.addData(String.format("  left,top (%d)", i), "%.03f , %.03f",
-                                          recognition.getLeft(), recognition.getTop());
-                        telemetry.addData(String.format("  right,bottom (%d)", i), "%.03f , %.03f",
-                                recognition.getRight(), recognition.getBottom());
-                      }
-                      telemetry.update();
+                        // step through the list of recognitions and display boundary info.
+                        int i = 0;
+                        for (Recognition recognition : updatedRecognitions) {
+                            telemetry.addData(String.format("label (%d)", i), recognition.getLabel());
+                            telemetry.addData(String.format("  left,top (%d)", i), "%.03f , %.03f",
+                                    recognition.getLeft(), recognition.getTop());
+                            telemetry.addData(String.format("  right,bottom (%d)", i), "%.03f , %.03f",
+                                    recognition.getRight(), recognition.getBottom());
+                        }
+                        telemetry.update();
                     }
                 }
             }
@@ -163,10 +163,12 @@
      */
     private void initTfod() {
         int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(
-            "tfodMonitorViewId", "id", hardwareMap.appContext.getPackageName());
+                "tfodMonitorViewId", "id", hardwareMap.appContext.getPackageName());
         TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);
         tfodParameters.minResultConfidence = 0.8f;
         tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);
         tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);
     }
+
+
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FrontRightWheel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FrontRightWheel.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FrontRightWheel.java
new file mode 100644
--- /dev/null	(date 1637606285198)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/FrontRightWheel.java	(date 1637606285198)
@@ -0,0 +1,240 @@
+package org.firstinspires.ftc.teamcode;
+
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+import com.qualcomm.robotcore.eventloop.opmode.OpMode;
+import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.util.ElapsedTime;
+
+@Autonomous(name="FrontRightWheel", group="Training")
+    public class FrontRightWheel extends OpMode {
+
+
+
+    DcMotor leftWheel;
+    DcMotor rightWheel;
+    DcMotor backLeftWheel;
+    DcMotor backRightWheel;
+    double drivePower = 0.5;
+     //1 rotation = 360
+
+
+
+
+
+    private ElapsedTime runtime= new ElapsedTime();
+
+    @Override
+    public void init() {
+        leftWheel = hardwareMap.dcMotor.get("left_wheel");
+        rightWheel = hardwareMap.dcMotor.get("right_wheel");
+        backRightWheel = hardwareMap.dcMotor.get("back_right_wheel");
+        backLeftWheel = hardwareMap.dcMotor.get("back_left_wheel");
+
+    }
+
+    public void Sleep(int milliseconds) {
+        try {
+            Thread.sleep(milliseconds);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+    public void resetEncoders() {
+        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+    }
+
+    @Override
+    public void start() {
+
+
+
+    }
+
+    @Override
+    public void loop() {
+        rightWheel.setPower(drivePower);
+    }
+    @Override
+    public void stop() {
+        leftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        rightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backLeftWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+        backRightWheel.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
+
+
+    }
+
+
+
+
+    public void diagonalLeft(int rotation) {
+        /*
+        backLeftWheel.setDirection(DcMotor.Direction.REVERSE);
+        rightWheel.setDirection(DcMotor.Direction.FORWARD);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(drivePower);
+        //sleep(milliseconds 1000);
+
+         */
+
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+
+
+
+    }
+
+    public void backwardsDiagonalLeft(int rotation) {
+        /*
+        backLeftWheel.setDirection(DcMotor.Direction.FORWARD);
+        rightWheel.setDirection(DcMotor.Direction.REVERSE);
+
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(drivePower);
+        //sleep(2000);
+
+         */
+
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+
+    }
+
+    public void diagonalRight(int rotation) {
+        /*
+        backRightWheel.setDirection(DcMotor.Direction.FORWARD);
+        leftWheel.setDirection(DcMotor.Direction.REVERSE);
+
+        leftWheel.setPower(drivePower);
+        backRightWheel.setPower(drivePower);
+
+         */
+
+        leftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        backRightWheel.setPower(drivePower);
+    }
+
+    public void horizontalRight(int rotation) {
+
+        leftWheel.setTargetPosition(-rotation);
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+        backRightWheel.setPower(drivePower);
+    }
+
+    public void horizontalLeft(int rotation) {
+
+        leftWheel.setTargetPosition(rotation);
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+        backRightWheel.setPower(-drivePower);
+    }
+
+    public void backwardsDiagonalRight(int rotation) {
+
+        leftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        backRightWheel.setPower(-drivePower);
+
+    }
+
+
+
+    public void forward(int rotation) {
+
+
+        leftWheel.setTargetPosition(-rotation);
+        rightWheel.setTargetPosition(rotation);
+        backLeftWheel.setTargetPosition(-rotation);
+        backRightWheel.setTargetPosition(rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(-drivePower);
+        rightWheel.setPower(drivePower);
+        backLeftWheel.setPower(-drivePower);
+        backRightWheel.setPower(drivePower);
+
+
+
+
+    }
+
+    public void backward(int rotation) {
+
+
+        leftWheel.setTargetPosition(rotation);
+        rightWheel.setTargetPosition(-rotation);
+        backLeftWheel.setTargetPosition(rotation);
+        backRightWheel.setTargetPosition(-rotation);
+
+        leftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        rightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backLeftWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+        backRightWheel.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+
+        leftWheel.setPower(drivePower);
+        rightWheel.setPower(-drivePower);
+        backLeftWheel.setPower(drivePower);
+        backRightWheel.setPower(-drivePower);
+
+
+
+    }
+
+
+
+
+
+
+}
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ConceptTensorFlowObjectDetection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ConceptTensorFlowObjectDetection.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ConceptTensorFlowObjectDetection.java
new file mode 100644
--- /dev/null	(date 1637524881792)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ConceptTensorFlowObjectDetection.java	(date 1637524881792)
@@ -0,0 +1,174 @@
+/* Copyright (c) 2019 FIRST. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted (subject to the limitations in the disclaimer below) provided that
+ * the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this list
+ * of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice, this
+ * list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * Neither the name of FIRST nor the names of its contributors may be used to endorse or
+ * promote products derived from this software without specific prior written permission.
+ *
+ * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
+ * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.firstinspires.ftc.teamcode;
+
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
+
+import org.firstinspires.ftc.robotcore.external.ClassFactory;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;
+import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection;
+import org.firstinspires.ftc.robotcore.external.tfod.Recognition;
+import org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector;
+
+import java.util.List;
+
+/**
+ * This 2020-2021 OpMode illustrates the basics of using the TensorFlow Object Detection API to
+ * determine the position of the Ultimate Goal game elements.
+ *
+ * Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.
+ * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list.
+ *
+ * IMPORTANT: In order to use this OpMode, you need to obtain your own Vuforia license key as
+ * is explained below.
+ */
+@Autonomous(name = "ConceptTensorFlowObjectDetectionTest", group = "Training")
+public class ConceptTensorFlowObjectDetection extends LinearOpMode {
+    private static final String TFOD_MODEL_ASSET = "FreightFrenzy_BCDM.tflite";
+    private static final String LABEL_FIRST_ELEMENT = "Quad";
+    private static final String LABEL_SECOND_ELEMENT = "Single";
+
+    /*
+     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which
+     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.
+     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer
+     * web site at https://developer.vuforia.com/license-manager.
+     *
+     * Vuforia license keys are always 380 characters long, and look as if they contain mostly
+     * random data. As an example, here is a example of a fragment of a valid key:
+     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...
+     * Once you've obtained a license key, copy the string from the Vuforia web site
+     * and paste it in to your code on the next line, between the double quotes.
+     */
+    private static final String VUFORIA_KEY =
+            "AceJqxr/////AAABmfhCK5bvWUGbtwq2Aklej7UU4PMgSzBzmvS8GTqRPrVjYpKWEX6XGiwzt85GlEialLkazXNjPIK9y/u4QVNGg9ZytchGG9StZFyP2Wo9GCBa32Zr9jLSDq4kNCpaxFgfV/VhkmqvdzQjPG+i3LlRB8gnK/VCrS8ofYJe907hpUg9z2vS9SnTWzrdLGA3eAOs6oAY4FUBgzze/FFV44ufBZWsNBxBC2RqwEX1m60Q07xUt20q9pf7nU+XPLkbZxp0FCsUWETjdk08M9Oh+fgJJ56cyVey7I98zPRH39b5aOze3ynMkjcW2BjkI5e2VQN6GWe17Q662qUBwJ5R/yaFV0avDp1+u5aQqN8xdl+dfVIp";
+
+    /**
+     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia
+     * localization engine.
+     */
+    private VuforiaLocalizer vuforia;
+
+    /**
+     * {@link #tfod} is the variable we will use to store our instance of the TensorFlow Object
+     * Detection engine.
+     */
+    private TFObjectDetector tfod;
+
+    @Override
+    public void runOpMode() {
+        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that
+        // first.
+        initVuforia();
+        initTfod();
+
+        /**
+         * Activate TensorFlow Object Detection before we wait for the start command.
+         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.
+         **/
+        if (tfod != null) {
+            tfod.activate();
+
+            // The TensorFlow software will scale the input images from the camera to a lower resolution.
+            // This can result in lower detection accuracy at longer distances (> 55cm or 22").
+            // If your target is at distance greater than 50 cm (20") you can adjust the magnification value
+            // to artificially zoom in to the center of image.  For best results, the "aspectRatio" argument
+            // should be set to the value of the images used to create the TensorFlow Object Detection model
+            // (typically 16/9).
+            tfod.setZoom(2.5, 16.0/9.0);
+        }
+
+        /** Wait for the game to begin */
+        telemetry.addData(">", "Press Play to start op mode");
+        telemetry.update();
+        waitForStart();
+
+        if (opModeIsActive()) {
+            while (opModeIsActive()) {
+                if (tfod != null) {
+                    // getUpdatedRecognitions() will return null if no new information is available since
+                    // the last time that call was made.
+                    List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();
+                    if (updatedRecognitions != null) {
+                        telemetry.addData("# Object Detected", updatedRecognitions.size());
+
+                        // step through the list of recognitions and display boundary info.
+                        int i = 0;
+                        for (Recognition recognition : updatedRecognitions) {
+                            telemetry.addData(String.format("label (%d)", i), recognition.getLabel());
+                            telemetry.addData(String.format("  left,top (%d)", i), "%.03f , %.03f",
+                                    recognition.getLeft(), recognition.getTop());
+                            telemetry.addData(String.format("  right,bottom (%d)", i), "%.03f , %.03f",
+                                    recognition.getRight(), recognition.getBottom());
+                        }
+                        telemetry.update();
+                    }
+                }
+            }
+        }
+
+        if (tfod != null) {
+            tfod.shutdown();
+        }
+    }
+
+    /**
+     * Initialize the Vuforia localization engine.
+     */
+    private void initVuforia() {
+        /*
+         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.
+         */
+        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();
+
+        parameters.vuforiaLicenseKey = VUFORIA_KEY;
+        parameters.cameraDirection = CameraDirection.BACK;
+
+        //  Instantiate the Vuforia engine
+        vuforia = ClassFactory.getInstance().createVuforia(parameters);
+
+        // Loading trackables is not necessary for the TensorFlow Object Detection engine.
+    }
+
+    /**
+     * Initialize the TensorFlow Object Detection engine.
+     */
+    private void initTfod() {
+        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(
+                "tfodMonitorViewId", "id", hardwareMap.appContext.getPackageName());
+        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);
+        tfodParameters.minResultConfidence = 0.8f;
+        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);
+        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_FIRST_ELEMENT, LABEL_SECOND_ELEMENT);
+    }
+
+
+}
